<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>DEFINE_STACK_OF</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#notes">NOTES</a></li>
	<li><a href="#return_values">RETURN VALUES</a></li>
	<li><a href="#history">HISTORY</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>DEFINE_STACK_OF, DEFINE_STACK_OF_CONST, DEFINE_SPECIAL_STACK_OF,
DEFINE_SPECIAL_STACK_OF_CONST,
sk_TYPE_num, sk_TYPE_value, sk_TYPE_new, sk_TYPE_new_null,
sk_TYPE_reserve, sk_TYPE_free, sk_TYPE_zero, sk_TYPE_delete,
sk_TYPE_delete_ptr, sk_TYPE_push, sk_TYPE_unshift, sk_TYPE_pop,
sk_TYPE_shift, sk_TYPE_pop_free, sk_TYPE_insert, sk_TYPE_set,
sk_TYPE_find, sk_TYPE_find_ex, sk_TYPE_find_all, sk_TYPE_sort,
sk_TYPE_is_sorted, sk_TYPE_dup, sk_TYPE_deep_copy, sk_TYPE_set_cmp_func,
sk_TYPE_new_reserve,
OPENSSL_sk_deep_copy, OPENSSL_sk_delete, OPENSSL_sk_delete_ptr,
OPENSSL_sk_dup, OPENSSL_sk_find, OPENSSL_sk_find_ex, OPENSSL_sk_find_all,
OPENSSL_sk_free, OPENSSL_sk_insert, OPENSSL_sk_is_sorted, OPENSSL_sk_new,
OPENSSL_sk_new_null, OPENSSL_sk_new_reserve, OPENSSL_sk_num, OPENSSL_sk_pop,
OPENSSL_sk_pop_free, OPENSSL_sk_push, OPENSSL_sk_reserve, OPENSSL_sk_set,
OPENSSL_sk_set_cmp_func, OPENSSL_sk_shift, OPENSSL_sk_sort,
OPENSSL_sk_unshift, OPENSSL_sk_value, OPENSSL_sk_zero
- stack container</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 <span class="comment">#include &lt;openssl/safestack.h&gt;</span>
</pre>
<pre>
 STACK_OF(TYPE)
 DEFINE_STACK_OF(TYPE)
 DEFINE_STACK_OF_CONST(TYPE)
 DEFINE_SPECIAL_STACK_OF(FUNCTYPE, TYPE)
 DEFINE_SPECIAL_STACK_OF_CONST(FUNCTYPE, TYPE)</pre>
<pre>
 <span class="variable">typedef</span> <span class="keyword">int</span> <span class="operator">(</span><span class="variable">*sk_TYPE_compfunc</span><span class="operator">)(</span><span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*const</span> <span class="variable">*a</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*const</span> <span class="variable">*b</span><span class="operator">);</span>
 <span class="variable">typedef</span> <span class="variable">TYPE</span> <span class="operator">*</span> <span class="operator">(</span><span class="variable">*sk_TYPE_copyfunc</span><span class="operator">)(</span><span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*a</span><span class="operator">);</span>
 <span class="variable">typedef</span> <span class="variable">void</span> <span class="operator">(</span><span class="variable">*sk_TYPE_freefunc</span><span class="operator">)(</span><span class="variable">TYPE</span> <span class="variable">*a</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_num</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_value</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">idx</span><span class="operator">);</span>
 <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk_TYPE_new</span><span class="operator">(</span><span class="variable">sk_TYPE_compfunc</span> <span class="variable">compare</span><span class="operator">);</span>
 <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk_TYPE_new_null</span><span class="operator">(</span><span class="variable">void</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_reserve</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">n</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">sk_TYPE_free</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">sk_TYPE_zero</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_delete</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">i</span><span class="operator">);</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_delete_ptr</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_push</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_unshift</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">);</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_pop</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_shift</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">sk_TYPE_pop_free</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">sk_TYPE_freefunc</span> <span class="variable">freefunc</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_insert</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">idx</span><span class="operator">);</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_set</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">idx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_find</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_find_ex</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_find_all</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="variable">TYPE</span> <span class="variable">*ptr</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*pnum</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">sk_TYPE_sort</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">sk_TYPE_is_sorted</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk_TYPE_dup</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">);</span>
 <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk_TYPE_deep_copy</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span>
                                   <span class="variable">sk_TYPE_copyfunc</span> <span class="variable">copyfunc</span><span class="operator">,</span>
                                   <span class="variable">sk_TYPE_freefunc</span> <span class="variable">freefunc</span><span class="operator">);</span>
 <span class="variable">sk_TYPE_compfunc</span> <span class="operator">(</span><span class="variable">*sk_TYPE_set_cmp_func</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span>
                                         <span class="variable">sk_TYPE_compfunc</span> <span class="variable">compare</span><span class="operator">));</span>
 <span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk_TYPE_new_reserve</span><span class="operator">(</span><span class="variable">sk_TYPE_compfunc</span> <span class="variable">compare</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">n</span><span class="operator">);</span>
</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Applications can create and use their own stacks by placing any of the macros
described below in a header file. These macros define typesafe inline
functions that wrap around the utility <strong>OPENSSL_sk_</strong> API.
In the description here, <strong><em>TYPE</em></strong> is used
as a placeholder for any of the OpenSSL datatypes, such as <strong>X509</strong>.</p>
<p>The <code>STACK_OF()</code> macro returns the name for a stack of the specified <strong><em>TYPE</em></strong>.
This is an opaque pointer to a structure declaration.
This can be used in every header file that references the stack.
There are several <strong>DEFINE...</strong> macros that create static inline functions
for all of the functions described on this page.
This should normally be used in one source file, and the stack manipulation
is wrapped with application-specific functions.</p>
<p><code>DEFINE_STACK_OF()</code> creates set of functions for a stack of <strong><em>TYPE</em></strong> elements.
The type is referenced by
<strong>STACK_OF</strong>(<strong><em>TYPE</em></strong>) and each function name begins with <strong>sk_<em>TYPE</em>_</strong>.
<code>DEFINE_STACK_OF_CONST()</code> is identical to <code>DEFINE_STACK_OF()</code> except
each element is constant.</p>
<pre>
 <span class="regex">/* DEFINE_STACK_OF(TYPE) */</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_value</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">idx</span><span class="operator">);</span>
 <span class="regex">/* DEFINE_STACK_OF_CONST(TYPE) */</span>
 <span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*sk_TYPE_value</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">idx</span><span class="operator">);</span>
</pre>
<p><code>DEFINE_SPECIAL_STACK_OF()</code> and <code>DEFINE_SPECIAL_STACK_OF_CONST()</code> are similar
except <strong>FUNCNAME</strong> is used in the function names:</p>
<pre>
 <span class="regex">/* DEFINE_SPECIAL_STACK_OF(TYPE, FUNCNAME) */</span>
 <span class="variable">TYPE</span> <span class="variable">*sk_FUNCNAME_value</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">idx</span><span class="operator">);</span>
 <span class="regex">/* DEFINE_SPECIAL_STACK_OF(TYPE, FUNCNAME) */</span>
 <span class="variable">const</span> <span class="variable">TYPE</span> <span class="variable">*sk_FUNCNAME_value</span><span class="operator">(</span><span class="variable">STACK_OF</span><span class="operator">(</span><span class="variable">TYPE</span><span class="operator">)</span> <span class="variable">*sk</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">idx</span><span class="operator">);</span>
</pre>
<p><strong>sk_<em>TYPE</em>_num</strong>() returns the number of elements in <em>sk</em> or -1 if <em>sk</em> is
NULL.</p>
<p><strong>sk_<em>TYPE</em>_value</strong>() returns element <em>idx</em> in <em>sk</em>, where <em>idx</em> starts at
zero. If <em>idx</em> is out of range then NULL is returned.</p>
<p><strong>sk_<em>TYPE</em>_new</strong>() allocates a new empty stack using comparison function
<em>compare</em>. If <em>compare</em> is NULL then no comparison function is used. This
function is equivalent to <strong>sk_<em>TYPE</em>_new_reserve</strong>(<em>compare</em>, 0).</p>
<p><strong>sk_<em>TYPE</em>_new_null</strong>() allocates a new empty stack with no comparison
function. This function is equivalent to <strong>sk_<em>TYPE</em>_new_reserve</strong>(NULL, 0).</p>
<p><strong>sk_<em>TYPE</em>_reserve</strong>() allocates additional memory in the <em>sk</em> structure
such that the next <em>n</em> calls to <strong>sk_<em>TYPE</em>_insert</strong>(), <strong>sk_<em>TYPE</em>_push</strong>()
or <strong>sk_<em>TYPE</em>_unshift</strong>() will not fail or cause memory to be allocated
or reallocated. If <em>n</em> is zero, any excess space allocated in the
<em>sk</em> structure is freed. On error <em>sk</em> is unchanged.</p>
<p><strong>sk_<em>TYPE</em>_new_reserve</strong>() allocates a new stack. The new stack will have
additional memory allocated to hold <em>n</em> elements if <em>n</em> is positive.
The next <em>n</em> calls to <strong>sk_<em>TYPE</em>_insert</strong>(), <strong>sk_<em>TYPE</em>_push</strong>() or
<strong>sk_<em>TYPE</em>_unshift</strong>() will not fail or cause memory to be allocated or
reallocated. If <em>n</em> is zero or less than zero, no memory is allocated.
<strong>sk_<em>TYPE</em>_new_reserve</strong>() also sets the comparison function <em>compare</em>
to the newly created stack. If <em>compare</em> is NULL then no comparison
function is used.</p>
<p><strong>sk_<em>TYPE</em>_set_cmp_func</strong>() sets the comparison function of <em>sk</em> to
<em>compare</em>. The previous comparison function is returned or NULL if there
was no previous comparison function.</p>
<p><strong>sk_<em>TYPE</em>_free</strong>() frees up the <em>sk</em> structure. It does <em>not</em> free up any
elements of <em>sk</em>. After this call <em>sk</em> is no longer valid.</p>
<p><strong>sk_<em>TYPE</em>_zero</strong>() sets the number of elements in <em>sk</em> to zero. It does not
free <em>sk</em> so after this call <em>sk</em> is still valid.</p>
<p><strong>sk_<em>TYPE</em>_pop_free</strong>() frees up all elements of <em>sk</em> and <em>sk</em> itself. The
free function <code>freefunc()</code> is called on each element to free it.</p>
<p><strong>sk_<em>TYPE</em>_delete</strong>() deletes element <em>i</em> from <em>sk</em>. It returns the deleted
element or NULL if <em>i</em> is out of range.</p>
<p><strong>sk_<em>TYPE</em>_delete_ptr</strong>() deletes element matching <em>ptr</em> from <em>sk</em>. It
returns the deleted element or NULL if no element matching <em>ptr</em> was found.</p>
<p><strong>sk_<em>TYPE</em>_insert</strong>() inserts <em>ptr</em> into <em>sk</em> at position <em>idx</em>. Any
existing elements at or after <em>idx</em> are moved downwards. If <em>idx</em> is out
of range the new element is appended to <em>sk</em>. <strong>sk_<em>TYPE</em>_insert</strong>() either
returns the number of elements in <em>sk</em> after the new element is inserted or
zero if an error (such as memory allocation failure) occurred.</p>
<p><strong>sk_<em>TYPE</em>_push</strong>() appends <em>ptr</em> to <em>sk</em> it is equivalent to:</p>
<pre>
 <span class="variable">sk_TYPE_insert</span><span class="operator">(</span><span class="variable">sk</span><span class="operator">,</span> <span class="variable">ptr</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">);</span>
</pre>
<p><strong>sk_<em>TYPE</em>_unshift</strong>() inserts <em>ptr</em> at the start of <em>sk</em> it is equivalent
to:</p>
<pre>
 <span class="variable">sk_TYPE_insert</span><span class="operator">(</span><span class="variable">sk</span><span class="operator">,</span> <span class="variable">ptr</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
</pre>
<p><strong>sk_<em>TYPE</em>_pop</strong>() returns and removes the last element from <em>sk</em>.</p>
<p><strong>sk_<em>TYPE</em>_shift</strong>() returns and removes the first element from <em>sk</em>.</p>
<p><strong>sk_<em>TYPE</em>_set</strong>() sets element <em>idx</em> of <em>sk</em> to <em>ptr</em> replacing the current
element. The new element value is returned or NULL if an error occurred:
this will only happen if <em>sk</em> is NULL or <em>idx</em> is out of range.</p>
<p><strong>sk_<em>TYPE</em>_find</strong>() searches <em>sk</em> for the element <em>ptr</em>.  In the case
where no comparison function has been specified, the function performs
a linear search for a pointer equal to <em>ptr</em>. The index of the first
matching element is returned or <strong>-1</strong> if there is no match. In the case
where a comparison function has been specified, <em>sk</em> is sorted and
<strong>sk_<em>TYPE</em>_find</strong>() returns the index of a matching element or <strong>-1</strong> if there
is no match. Note that, in this case the comparison function will usually
compare the values pointed to rather than the pointers themselves and
the order of elements in <em>sk</em> can change. Note that because the stack may be
sorted as the result of a <strong>sk_<em>TYPE</em>_find</strong>() call, if a lock is being used to
synchronise access to the stack across multiple threads, then that lock must be
a &quot;write&quot; lock.</p>
<p><strong>sk_<em>TYPE</em>_find_ex</strong>() operates like <strong>sk_<em>TYPE</em>_find</strong>() except when a
comparison function has been specified and no matching element is found.
Instead of returning <strong>-1</strong>, <strong>sk_<em>TYPE</em>_find_ex</strong>() returns the index of the
element either before or after the location where <em>ptr</em> would be if it were
present in <em>sk</em>. The function also does not guarantee that the first matching
element in the sorted stack is returned.</p>
<p><strong>sk_<em>TYPE</em>_find_all</strong>() operates like <strong>sk_<em>TYPE</em>_find</strong>() but it also
sets the <em>*pnum</em> to number of matching elements in the stack. In case
no comparison function has been specified the <em>*pnum</em> will be always set
to 1 if matching element was found, 0 otherwise.</p>
<p><strong>sk_<em>TYPE</em>_sort</strong>() sorts <em>sk</em> using the supplied comparison function.</p>
<p><strong>sk_<em>TYPE</em>_is_sorted</strong>() returns <strong>1</strong> if <em>sk</em> is sorted and <strong>0</strong> otherwise.</p>
<p><strong>sk_<em>TYPE</em>_dup</strong>() returns a shallow copy of <em>sk</em>
or an empty stack if the passed stack is NULL.
Note the pointers in the copy are identical to the original.</p>
<p><strong>sk_<em>TYPE</em>_deep_copy</strong>() returns a new stack where each element has been
copied or an empty stack if the passed stack is NULL.
Copying is performed by the supplied <code>copyfunc()</code> and freeing by <code>freefunc()</code>.
The function <code>freefunc()</code> is only called if an error occurs.</p>
<p>
</p>
<hr />
<h1><a name="notes">NOTES</a></h1>
<p>Care should be taken when accessing stacks in multi-threaded environments.
Any operation which increases the size of a stack such as <strong>sk_<em>TYPE</em>_insert</strong>()
or <strong>sk_<em>TYPE</em>_push</strong>() can &quot;grow&quot; the size of an internal array and cause race
conditions if the same stack is accessed in a different thread. Operations such
as <strong>sk_<em>TYPE</em>_find</strong>() and <strong>sk_<em>TYPE</em>_sort</strong>() can also reorder the stack.</p>
<p>Any comparison function supplied should use a metric suitable
for use in a binary search operation. That is it should return zero, a
positive or negative value if <em>a</em> is equal to, greater than
or less than <em>b</em> respectively.</p>
<p>Care should be taken when checking the return values of the functions
<strong>sk_<em>TYPE</em>_find</strong>() and <strong>sk_<em>TYPE</em>_find_ex</strong>(). They return an index to the
matching element. In particular <strong>0</strong> indicates a matching first element.
A failed search is indicated by a <strong>-1</strong> return value.</p>
<p><code>STACK_OF()</code>, <code>DEFINE_STACK_OF()</code>, <code>DEFINE_STACK_OF_CONST()</code>, and
<code>DEFINE_SPECIAL_STACK_OF()</code> are implemented as macros.</p>
<p>It is not an error to call <strong>sk_<em>TYPE</em>_num</strong>(), <strong>sk_<em>TYPE</em>_value</strong>(),
<strong>sk_<em>TYPE</em>_free</strong>(), <strong>sk_<em>TYPE</em>_zero</strong>(), <strong>sk_<em>TYPE</em>_pop_free</strong>(),
<strong>sk_<em>TYPE</em>_delete</strong>(), <strong>sk_<em>TYPE</em>_delete_ptr</strong>(), <strong>sk_<em>TYPE</em>_pop</strong>(),
<strong>sk_<em>TYPE</em>_shift</strong>(), <strong>sk_<em>TYPE</em>_find</strong>(), <strong>sk_<em>TYPE</em>_find_ex</strong>(),
and <strong>sk_<em>TYPE</em>_find_all</strong>() on a NULL stack, empty stack, or with
an invalid index. An error is not raised in these conditions.</p>
<p>The underlying utility <strong>OPENSSL_sk_</strong> API should not be used directly.
It defines these functions: <code>OPENSSL_sk_deep_copy()</code>,
<code>OPENSSL_sk_delete()</code>, <code>OPENSSL_sk_delete_ptr()</code>, <code>OPENSSL_sk_dup()</code>,
<code>OPENSSL_sk_find()</code>, <code>OPENSSL_sk_find_ex()</code>, <code>OPENSSL_sk_find_all()</code>,
<code>OPENSSL_sk_free()</code>, <code>OPENSSL_sk_insert()</code>, <code>OPENSSL_sk_is_sorted()</code>,
<code>OPENSSL_sk_new()</code>, <code>OPENSSL_sk_new_null()</code>, <code>OPENSSL_sk_new_reserve()</code>,
<code>OPENSSL_sk_num()</code>, <code>OPENSSL_sk_pop()</code>, <code>OPENSSL_sk_pop_free()</code>, <code>OPENSSL_sk_push()</code>,
<code>OPENSSL_sk_reserve()</code>, <code>OPENSSL_sk_set()</code>, <code>OPENSSL_sk_set_cmp_func()</code>,
<code>OPENSSL_sk_shift()</code>, <code>OPENSSL_sk_sort()</code>, <code>OPENSSL_sk_unshift()</code>,
<code>OPENSSL_sk_value()</code>, <code>OPENSSL_sk_zero()</code>.</p>
<p>
</p>
<hr />
<h1><a name="return_values">RETURN VALUES</a></h1>
<p><strong>sk_<em>TYPE</em>_num</strong>() returns the number of elements in the stack or <strong>-1</strong> if the
passed stack is NULL.</p>
<p><strong>sk_<em>TYPE</em>_value</strong>() returns a pointer to a stack element or NULL if the
index is out of range.</p>
<p><strong>sk_<em>TYPE</em>_new</strong>(), <strong>sk_<em>TYPE</em>_new_null</strong>() and <strong>sk_<em>TYPE</em>_new_reserve</strong>()
return an empty stack or NULL if an error occurs.</p>
<p><strong>sk_<em>TYPE</em>_reserve</strong>() returns <strong>1</strong> on successful allocation of the required
memory or <strong>0</strong> on error.</p>
<p><strong>sk_<em>TYPE</em>_set_cmp_func</strong>() returns the old comparison function or NULL if
there was no old comparison function.</p>
<p><strong>sk_<em>TYPE</em>_free</strong>(), <strong>sk_<em>TYPE</em>_zero</strong>(), <strong>sk_<em>TYPE</em>_pop_free</strong>() and
<strong>sk_<em>TYPE</em>_sort</strong>() do not return values.</p>
<p><strong>sk_<em>TYPE</em>_pop</strong>(), <strong>sk_<em>TYPE</em>_shift</strong>(), <strong>sk_<em>TYPE</em>_delete</strong>() and
<strong>sk_<em>TYPE</em>_delete_ptr</strong>() return a pointer to the deleted element or NULL
on error.</p>
<p><strong>sk_<em>TYPE</em>_insert</strong>(), <strong>sk_<em>TYPE</em>_push</strong>() and <strong>sk_<em>TYPE</em>_unshift</strong>() return
the total number of elements in the stack and 0 if an error occurred.
<strong>sk_<em>TYPE</em>_push</strong>() further returns -1 if <em>sk</em> is NULL.</p>
<p><strong>sk_<em>TYPE</em>_set</strong>() returns a pointer to the replacement element or NULL on
error.</p>
<p><strong>sk_<em>TYPE</em>_find</strong>() and <strong>sk_<em>TYPE</em>_find_ex</strong>() return an index to the found
element or <strong>-1</strong> on error.</p>
<p><strong>sk_<em>TYPE</em>_is_sorted</strong>() returns <strong>1</strong> if the stack is sorted and <strong>0</strong> if it is
not.</p>
<p><strong>sk_<em>TYPE</em>_dup</strong>() and <strong>sk_<em>TYPE</em>_deep_copy</strong>() return a pointer to the copy
of the stack or NULL on error.</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p>Before OpenSSL 1.1.0, this was implemented via macros and not inline functions
and was not a public API.</p>
<p><strong>sk_<em>TYPE</em>_reserve</strong>() and <strong>sk_<em>TYPE</em>_new_reserve</strong>() were added in OpenSSL
1.1.1.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright 2000-2022 The OpenSSL Project Authors. All Rights Reserved.</p>
<p>Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<a href="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</a>.</p>

</body>

</html>
