<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>OPENSSL_malloc</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#return_values">RETURN VALUES</a></li>
	<li><a href="#history">HISTORY</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>OPENSSL_malloc_init,
OPENSSL_malloc, OPENSSL_zalloc, OPENSSL_realloc, OPENSSL_free,
OPENSSL_clear_realloc, OPENSSL_clear_free, OPENSSL_cleanse,
CRYPTO_malloc, CRYPTO_zalloc, CRYPTO_realloc, CRYPTO_free,
OPENSSL_strdup, OPENSSL_strndup,
OPENSSL_memdup, OPENSSL_strlcpy, OPENSSL_strlcat,
CRYPTO_strdup, CRYPTO_strndup,
OPENSSL_mem_debug_push, OPENSSL_mem_debug_pop,
CRYPTO_mem_debug_push, CRYPTO_mem_debug_pop,
CRYPTO_clear_realloc, CRYPTO_clear_free,
CRYPTO_malloc_fn, CRYPTO_realloc_fn, CRYPTO_free_fn,
CRYPTO_get_mem_functions, CRYPTO_set_mem_functions,
CRYPTO_get_alloc_counts,
CRYPTO_set_mem_debug, CRYPTO_mem_ctrl,
CRYPTO_mem_leaks, CRYPTO_mem_leaks_fp, CRYPTO_mem_leaks_cb,
OPENSSL_MALLOC_FAILURES,
OPENSSL_MALLOC_FD
- Memory allocation functions</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 <span class="comment">#include &lt;openssl/crypto.h&gt;</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">OPENSSL_malloc_init</span><span class="operator">(</span><span class="variable">void</span><span class="operator">);</span>
</pre>
<pre>
 <span class="variable">void</span> <span class="variable">*OPENSSL_malloc</span><span class="operator">(</span><span class="variable">size_t</span> <span class="variable">num</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">*OPENSSL_zalloc</span><span class="operator">(</span><span class="variable">size_t</span> <span class="variable">num</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">*OPENSSL_realloc</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*addr</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">num</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">OPENSSL_free</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*addr</span><span class="operator">);</span>
 <span class="variable">char</span> <span class="variable">*OPENSSL_strdup</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*str</span><span class="operator">);</span>
 <span class="variable">char</span> <span class="variable">*OPENSSL_strndup</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*str</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="regex">s);
 size_t OPENSSL_strlcat(char *dst, const char *src, size_t size);
 size_t OPENSSL_strlcpy(char *dst, const char *src, size_t size)</span><span class="operator">;</span>
 <span class="variable">void</span> <span class="variable">*OPENSSL_memdup</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*data</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="regex">s);
 void *OPENSSL_clear_realloc(void *p, size_t old_len, size_t num);
 void OPENSSL_clear_free(void *str, size_t num)</span><span class="operator">;</span>
 <span class="variable">void</span> <span class="variable">OPENSSL_cleanse</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*ptr</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">len</span><span class="operator">);</span>
</pre>
<pre>
 <span class="variable">void</span> <span class="variable">*CRYPTO_malloc</span><span class="operator">(</span><span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">*CRYPTO_zalloc</span><span class="operator">(</span><span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">*CRYPTO_realloc</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*p</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">CRYPTO_free</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*str</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="operator">*,</span> <span class="keyword">int</span><span class="operator">);</span>
 <span class="variable">char</span> <span class="variable">*CRYPTO_strdup</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*p</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">char</span> <span class="variable">*CRYPTO_strndup</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*p</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">*CRYPTO_clear_realloc</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*p</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">old_len</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span>
                            <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">CRYPTO_clear_free</span><span class="operator">(</span><span class="variable">void</span> <span class="variable">*str</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="operator">*,</span> <span class="keyword">int</span><span class="operator">);</span>
</pre>
<pre>
 <span class="variable">typedef</span> <span class="variable">void</span> <span class="operator">*(</span><span class="variable">*CRYPTO_malloc_fn</span><span class="operator">)(</span><span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">typedef</span> <span class="variable">void</span> <span class="operator">*(</span><span class="variable">*CRYPTO_realloc_fn</span><span class="operator">)(</span><span class="variable">void</span> <span class="variable">*addr</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">num</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span>
                                    <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">typedef</span> <span class="variable">void</span> <span class="operator">(</span><span class="variable">*CRYPTO_free_fn</span><span class="operator">)(</span><span class="variable">void</span> <span class="variable">*addr</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">CRYPTO_get_mem_functions</span><span class="operator">(</span><span class="variable">CRYPTO_malloc_fn</span> <span class="variable">*malloc_fn</span><span class="operator">,</span>
                               <span class="variable">CRYPTO_realloc_fn</span> <span class="variable">*realloc_fn</span><span class="operator">,</span>
                               <span class="variable">CRYPTO_free_fn</span> <span class="variable">*free_fn</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">CRYPTO_set_mem_functions</span><span class="operator">(</span><span class="variable">CRYPTO_malloc_fn</span> <span class="variable">malloc_fn</span><span class="operator">,</span>
                              <span class="variable">CRYPTO_realloc_fn</span> <span class="variable">realloc_fn</span><span class="operator">,</span>
                              <span class="variable">CRYPTO_free_fn</span> <span class="variable">free_fn</span><span class="operator">);</span>
</pre>
<pre>
 <span class="variable">void</span> <span class="variable">CRYPTO_get_alloc_counts</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">*mcount</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*rcount</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*fcount</span><span class="operator">);</span>
</pre>
<pre>
 env OPENSSL_MALLOC_FAILURES=... &lt;application&gt;
 env OPENSSL_MALLOC_FD=... &lt;application&gt;</pre>
<p>The following functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining <strong>OPENSSL_API_COMPAT</strong> with a suitable version value,
see <em>openssl_user_macros(7)</em>:</p>
<pre>
 <span class="keyword">int</span> <span class="variable">CRYPTO_mem_leaks</span><span class="operator">(</span><span class="variable">BIO</span> <span class="variable">*b</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">CRYPTO_mem_leaks_fp</span><span class="operator">(</span><span class="variable">FILE</span> <span class="variable">*fp</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">CRYPTO_mem_leaks_cb</span><span class="operator">(</span><span class="keyword">int</span> <span class="operator">(</span><span class="variable">*cb</span><span class="operator">)(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*str</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">len</span><span class="operator">,</span> <span class="variable">void</span> <span class="variable">*u</span><span class="operator">),</span>
                         <span class="variable">void</span> <span class="variable">*u</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">CRYPTO_set_mem_debug</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">onoff</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">CRYPTO_mem_ctrl</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">mode</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">OPENSSL_mem_debug_push</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*info</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">OPENSSL_mem_debug_pop</span><span class="operator">(</span><span class="variable">void</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">CRYPTO_mem_debug_push</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*info</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*file</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">line</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">CRYPTO_mem_debug_pop</span><span class="operator">(</span><span class="variable">void</span><span class="operator">);</span>
</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>OpenSSL memory allocation is handled by the <strong>OPENSSL_xxx</strong> API. These are
generally macro's that add the standard C <strong>__FILE__</strong> and <strong>__LINE__</strong>
parameters and call a lower-level <strong>CRYPTO_xxx</strong> API.
Some functions do not add those parameters, but exist for consistency.</p>
<p><code>OPENSSL_malloc_init()</code> does nothing and does not need to be called. It is
included for compatibility with older versions of OpenSSL.</p>
<p><code>OPENSSL_malloc()</code>, <code>OPENSSL_realloc()</code>, and <code>OPENSSL_free()</code> are like the
C <code>malloc()</code>, <code>realloc()</code>, and <code>free()</code> functions.
<code>OPENSSL_zalloc()</code> calls <code>memset()</code> to zero the memory before returning.</p>
<p><code>OPENSSL_clear_realloc()</code> and <code>OPENSSL_clear_free()</code> should be used
when the buffer at <strong>addr</strong> holds sensitive information.
The old buffer is filled with zero's by calling <code>OPENSSL_cleanse()</code>
before ultimately calling <code>OPENSSL_free()</code>.</p>
<p><code>OPENSSL_cleanse()</code> fills <strong>ptr</strong> of size <strong>len</strong> with a string of 0's.
Use <code>OPENSSL_cleanse()</code> with care if the memory is a mapping of a file.
If the storage controller uses write compression, then it's possible
that sensitive tail bytes will survive zeroization because the block of
zeros will be compressed. If the storage controller uses wear leveling,
then the old sensitive data will not be overwritten; rather, a block of
0's will be written at a new physical location.</p>
<p><code>OPENSSL_strdup()</code>, <code>OPENSSL_strndup()</code> and <code>OPENSSL_memdup()</code> are like the
equivalent C functions, except that memory is allocated by calling the
<code>OPENSSL_malloc()</code> and should be released by calling <code>OPENSSL_free()</code>.</p>
<p><code>OPENSSL_strlcpy()</code>,
<code>OPENSSL_strlcat()</code> and <code>OPENSSL_strnlen()</code> are equivalents of the common C
library functions and are provided for portability.</p>
<p>If no allocations have been done, it is possible to &quot;swap out&quot; the default
implementations for <code>OPENSSL_malloc()</code>, <code>OPENSSL_realloc()</code> and <code>OPENSSL_free()</code>
and replace them with alternate versions.
<code>CRYPTO_get_mem_functions()</code> function fills in the given arguments with the
function pointers for the current implementations.
With <code>CRYPTO_set_mem_functions()</code>, you can specify a different set of functions.
If any of <strong>malloc_fn</strong>, <strong>realloc_fn</strong>, or <strong>free_fn</strong> are NULL, then
the function is not changed.
While it's permitted to swap out only a few and not all the functions
with <code>CRYPTO_set_mem_functions()</code>, it's recommended to swap them all out
at once.</p>
<p>If the library is built with the <code>crypto-mdebug</code> option, then one
function, <code>CRYPTO_get_alloc_counts()</code>, and two additional environment
variables, <strong>OPENSSL_MALLOC_FAILURES</strong> and <strong>OPENSSL_MALLOC_FD</strong>,
are available.</p>
<p>The function <code>CRYPTO_get_alloc_counts()</code> fills in the number of times
each of <code>CRYPTO_malloc()</code>, <code>CRYPTO_realloc()</code>, and <code>CRYPTO_free()</code> have been
called, into the values pointed to by <strong>mcount</strong>, <strong>rcount</strong>, and <strong>fcount</strong>,
respectively.  If a pointer is NULL, then the corresponding count is not stored.</p>
<p>The variable
<strong>OPENSSL_MALLOC_FAILURES</strong> controls how often allocations should fail.
It is a set of fields separated by semicolons, which each field is a count
(defaulting to zero) and an optional atsign and percentage (defaulting
to 100).  If the count is zero, then it lasts forever.  For example,
<code>100;@25</code> or <code>100@0;0@25</code> means the first 100 allocations pass, then all
other allocations (until the program exits or crashes) have a 25% chance of
failing.</p>
<p>If the variable <strong>OPENSSL_MALLOC_FD</strong> is parsed as a positive integer, then
it is taken as an open file descriptor. This is used in conjunction with
<strong>OPENSSL_MALLOC_FAILURES</strong> described above. For every allocation it will log
details about how many allocations there have been so far, what percentage
chance there is for this allocation failing, and whether it has actually failed.
The following example in classic shell syntax shows how to use this (will not
work on all platforms):</p>
<pre>
  <span class="variable">OPENSSL_MALLOC_FAILURES</span><span class="operator">=</span><span class="string">'200;@10'</span>
  <span class="variable">export</span> <span class="variable">OPENSSL_MALLOC_FAILURES</span>
  <span class="variable">OPENSSL_MALLOC_FD</span><span class="operator">=</span><span class="number">3</span>
  <span class="variable">export</span> <span class="variable">OPENSSL_MALLOC_FD</span>
  <span class="operator">...</span><span class="variable">app</span> <span class="variable">invocation</span><span class="operator">...</span> <span class="number">3</span><span class="operator">&gt;</span><span class="regex">/tmp/log</span><span class="variable">$$</span>
</pre>
<p>
</p>
<hr />
<h1><a name="return_values">RETURN VALUES</a></h1>
<p><code>OPENSSL_malloc_init()</code>, <code>OPENSSL_free()</code>, <code>OPENSSL_clear_free()</code>
<code>CRYPTO_free()</code>, <code>CRYPTO_clear_free()</code> and <code>CRYPTO_get_mem_functions()</code>
return no value.</p>
<p><code>OPENSSL_malloc()</code>, <code>OPENSSL_zalloc()</code>, <code>OPENSSL_realloc()</code>,
<code>OPENSSL_clear_realloc()</code>,
<code>CRYPTO_malloc()</code>, <code>CRYPTO_zalloc()</code>, <code>CRYPTO_realloc()</code>,
<code>CRYPTO_clear_realloc()</code>,
<code>OPENSSL_strdup()</code>, and <code>OPENSSL_strndup()</code>
return a pointer to allocated memory or NULL on error.</p>
<p><code>CRYPTO_set_mem_functions()</code> returns 1 on success or 0 on failure (almost
always because allocations have already happened).</p>
<p><code>CRYPTO_mem_leaks()</code>, <code>CRYPTO_mem_leaks_fp()</code>, <code>CRYPTO_mem_leaks_cb()</code>,
<code>CRYPTO_set_mem_debug()</code>, and <code>CRYPTO_mem_ctrl()</code> are deprecated and are no-ops that
always return -1.
<code>OPENSSL_mem_debug_push()</code>, <code>OPENSSL_mem_debug_pop()</code>,
<code>CRYPTO_mem_debug_push()</code>, and <code>CRYPTO_mem_debug_pop()</code>
are deprecated and are no-ops that always return 0.</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p><code>OPENSSL_mem_debug_push()</code>, <code>OPENSSL_mem_debug_pop()</code>,
<code>CRYPTO_mem_debug_push()</code>, <code>CRYPTO_mem_debug_pop()</code>,
<code>CRYPTO_mem_leaks()</code>, <code>CRYPTO_mem_leaks_fp()</code>,
<code>CRYPTO_mem_leaks_cb()</code>, <code>CRYPTO_set_mem_debug()</code>, <code>CRYPTO_mem_ctrl()</code>
were deprecated in OpenSSL 3.0.
The memory-leak checking has been deprecated in OpenSSL 3.0 in favor of
clang's memory and leak sanitizer.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright 2016-2022 The OpenSSL Project Authors. All Rights Reserved.</p>
<p>Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<a href="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</a>.</p>

</body>

</html>
