<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>EVP_EncryptInit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#parameters">PARAMETERS</a></li>
	<ul>

		<li><a href="#gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a></li>
		<li><a href="#gettable_and_settable_evp_cipher_ctx_parameters">Gettable and Settable EVP_CIPHER_CTX parameters</a></li>
		<li><a href="#gettable_evp_cipher_ctx_parameters">Gettable EVP_CIPHER_CTX parameters</a></li>
		<li><a href="#settable_evp_cipher_ctx_parameters">Settable EVP_CIPHER_CTX parameters</a></li>
	</ul>

	<li><a href="#controls">CONTROLS</a></li>
	<li><a href="#flags">FLAGS</a></li>
	<li><a href="#return_values">RETURN VALUES</a></li>
	<li><a href="#cipher_listing">CIPHER LISTING</a></li>
	<li><a href="#aead_interface">AEAD INTERFACE</a></li>
	<ul>

		<li><a href="#gcm_and_ocb_modes">GCM and OCB Modes</a></li>
		<li><a href="#ccm_mode">CCM Mode</a></li>
		<li><a href="#siv_mode">SIV Mode</a></li>
		<li><a href="#chacha20_poly1305">ChaCha20-Poly1305</a></li>
	</ul>

	<li><a href="#notes">NOTES</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#examples">EXAMPLES</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#history">HISTORY</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>EVP_CIPHER_fetch,
EVP_CIPHER_up_ref,
EVP_CIPHER_free,
EVP_CIPHER_CTX_new,
EVP_CIPHER_CTX_reset,
EVP_CIPHER_CTX_free,
EVP_EncryptInit_ex,
EVP_EncryptInit_ex2,
EVP_EncryptUpdate,
EVP_EncryptFinal_ex,
EVP_DecryptInit_ex,
EVP_DecryptInit_ex2,
EVP_DecryptUpdate,
EVP_DecryptFinal_ex,
EVP_CipherInit_ex,
EVP_CipherInit_ex2,
EVP_CipherUpdate,
EVP_CipherFinal_ex,
EVP_CIPHER_CTX_set_key_length,
EVP_CIPHER_CTX_ctrl,
EVP_EncryptInit,
EVP_EncryptFinal,
EVP_DecryptInit,
EVP_DecryptFinal,
EVP_CipherInit,
EVP_CipherFinal,
EVP_Cipher,
EVP_get_cipherbyname,
EVP_get_cipherbynid,
EVP_get_cipherbyobj,
EVP_CIPHER_is_a,
EVP_CIPHER_get0_name,
EVP_CIPHER_get0_description,
EVP_CIPHER_names_do_all,
EVP_CIPHER_get0_provider,
EVP_CIPHER_get_nid,
EVP_CIPHER_get_params,
EVP_CIPHER_gettable_params,
EVP_CIPHER_get_block_size,
EVP_CIPHER_get_key_length,
EVP_CIPHER_get_iv_length,
EVP_CIPHER_get_flags,
EVP_CIPHER_get_mode,
EVP_CIPHER_get_type,
EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_get0_cipher,
EVP_CIPHER_CTX_get1_cipher,
EVP_CIPHER_CTX_get0_name,
EVP_CIPHER_CTX_get_nid,
EVP_CIPHER_CTX_get_params,
EVP_CIPHER_gettable_ctx_params,
EVP_CIPHER_CTX_gettable_params,
EVP_CIPHER_CTX_set_params,
EVP_CIPHER_settable_ctx_params,
EVP_CIPHER_CTX_settable_params,
EVP_CIPHER_CTX_get_block_size,
EVP_CIPHER_CTX_get_key_length,
EVP_CIPHER_CTX_get_iv_length,
EVP_CIPHER_CTX_get_tag_length,
EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data,
EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_set_flags,
EVP_CIPHER_CTX_clear_flags,
EVP_CIPHER_CTX_test_flags,
EVP_CIPHER_CTX_get_type,
EVP_CIPHER_CTX_get_mode,
EVP_CIPHER_CTX_get_num,
EVP_CIPHER_CTX_set_num,
EVP_CIPHER_CTX_is_encrypting,
EVP_CIPHER_param_to_asn1,
EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding,
EVP_enc_null,
EVP_CIPHER_do_all_provided,
EVP_CIPHER_nid,
EVP_CIPHER_name,
EVP_CIPHER_block_size,
EVP_CIPHER_key_length,
EVP_CIPHER_iv_length,
EVP_CIPHER_flags,
EVP_CIPHER_mode,
EVP_CIPHER_type,
EVP_CIPHER_CTX_encrypting,
EVP_CIPHER_CTX_nid,
EVP_CIPHER_CTX_block_size,
EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length,
EVP_CIPHER_CTX_tag_length,
EVP_CIPHER_CTX_num,
EVP_CIPHER_CTX_type,
EVP_CIPHER_CTX_mode
- EVP cipher routines</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 <span class="comment">#include &lt;openssl/evp.h&gt;</span>
</pre>
<pre>
 <span class="variable">EVP_CIPHER</span> <span class="variable">*EVP_CIPHER_fetch</span><span class="operator">(</span><span class="variable">OSSL_LIB_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*algorithm</span><span class="operator">,</span>
                              <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*properties</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_up_ref</span><span class="operator">(</span><span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">EVP_CIPHER_free</span><span class="operator">(</span><span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*EVP_CIPHER_CTX_new</span><span class="operator">(</span><span class="variable">void</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_reset</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_EncryptInit_ex</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                        <span class="variable">ENGINE</span> <span class="variable">*impl</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_EncryptInit_ex2</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                         <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">,</span>
                         <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">params</span><span class="operator">[]</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_EncryptUpdate</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*out</span><span class="operator">,</span>
                       <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*in</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">inl</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_EncryptFinal_ex</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*out</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_DecryptInit_ex</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                        <span class="variable">ENGINE</span> <span class="variable">*impl</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_DecryptInit_ex2</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                         <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">,</span>
                         <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">params</span><span class="operator">[]</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_DecryptUpdate</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*out</span><span class="operator">,</span>
                       <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*in</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">inl</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_DecryptFinal_ex</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*outm</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_CipherInit_ex</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                       <span class="variable">ENGINE</span> <span class="variable">*impl</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">enc</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CipherInit_ex2</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                        <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">,</span>
                        <span class="keyword">int</span> <span class="variable">enc</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">params</span><span class="operator">[]</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CipherUpdate</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*out</span><span class="operator">,</span>
                      <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*in</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">inl</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CipherFinal_ex</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*outm</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_EncryptInit</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                     <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_EncryptFinal</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*out</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_DecryptInit</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                     <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_DecryptFinal</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*outm</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_CipherInit</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*type</span><span class="operator">,</span>
                    <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">enc</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CipherFinal</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*outm</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">*outl</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_Cipher</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*out</span><span class="operator">,</span>
                <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*in</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="keyword">int</span> <span class="variable">inl</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_set_padding</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*x</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">padding</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_set_key_length</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*x</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">keylen</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_ctrl</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">cmd</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">p1</span><span class="operator">,</span> <span class="variable">void</span> <span class="variable">*p2</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_rand_key</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">EVP_CIPHER_CTX_set_flags</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">flags</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">EVP_CIPHER_CTX_clear_flags</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">flags</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_test_flags</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">flags</span><span class="operator">);</span>
</pre>
<pre>
 <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*EVP_get_cipherbyname</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*name</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*EVP_get_cipherbynid</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">nid</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*EVP_get_cipherbyobj</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">ASN1_OBJECT</span> <span class="variable">*a</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_get_nid</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*e</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_is_a</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*name</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_names_do_all</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">,</span>
                             <span class="variable">void</span> <span class="operator">(</span><span class="variable">*fn</span><span class="operator">)(</span><span class="variable">const</span> <span class="variable">char</span> <span class="variable">*name</span><span class="operator">,</span> <span class="variable">void</span> <span class="variable">*data</span><span class="operator">),</span>
                             <span class="variable">void</span> <span class="variable">*data</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*EVP_CIPHER_get0_name</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*EVP_CIPHER_get0_description</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">OSSL_PROVIDER</span> <span class="variable">*EVP_CIPHER_get0_provider</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_get_block_size</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*e</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_get_key_length</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*e</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_get_iv_length</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*e</span><span class="operator">);</span>
 <span class="variable">unsigned</span> <span class="variable">long</span> <span class="variable">EVP_CIPHER_get_flags</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*e</span><span class="operator">);</span>
 <span class="variable">unsigned</span> <span class="variable">long</span> <span class="variable">EVP_CIPHER_get_mode</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*e</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_get_type</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
</pre>
<pre>
 <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*EVP_CIPHER_CTX_get0_cipher</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="variable">EVP_CIPHER</span> <span class="variable">*EVP_CIPHER_CTX_get1_cipher</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_nid</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*EVP_CIPHER_CTX_get0_name</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_get_params</span><span class="operator">(</span><span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">,</span> <span class="variable">OSSL_PARAM</span> <span class="variable">params</span><span class="operator">[]</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_set_params</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">params</span><span class="operator">[]</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_params</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">OSSL_PARAM</span> <span class="variable">params</span><span class="operator">[]</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">*EVP_CIPHER_gettable_params</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">*EVP_CIPHER_settable_ctx_params</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">*EVP_CIPHER_gettable_ctx_params</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">*EVP_CIPHER_CTX_settable_params</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="variable">const</span> <span class="variable">OSSL_PARAM</span> <span class="variable">*EVP_CIPHER_CTX_gettable_params</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_block_size</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_key_length</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_iv_length</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_tag_length</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">*EVP_CIPHER_CTX_get_app_data</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="variable">void</span> <span class="variable">EVP_CIPHER_CTX_set_app_data</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="variable">void</span> <span class="variable">*data</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_type</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_mode</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_get_num</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_set_num</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">num</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_is_encrypting</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
</pre>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_param_to_asn1</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*c</span><span class="operator">,</span> <span class="variable">ASN1_TYPE</span> <span class="variable">*type</span><span class="operator">);</span>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_asn1_to_param</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*c</span><span class="operator">,</span> <span class="variable">ASN1_TYPE</span> <span class="variable">*type</span><span class="operator">);</span>
</pre>
<pre>
 <span class="variable">void</span> <span class="variable">EVP_CIPHER_do_all_provided</span><span class="operator">(</span><span class="variable">OSSL_LIB_CTX</span> <span class="variable">*libctx</span><span class="operator">,</span>
                                 <span class="variable">void</span> <span class="operator">(</span><span class="variable">*fn</span><span class="operator">)(</span><span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span><span class="operator">,</span> <span class="variable">void</span> <span class="variable">*arg</span><span class="operator">),</span>
                                 <span class="variable">void</span> <span class="variable">*arg</span><span class="operator">);</span>
</pre>
<pre>
 <span class="comment">#define EVP_CIPHER_nid EVP_CIPHER_get_nid</span>
 <span class="comment">#define EVP_CIPHER_name EVP_CIPHER_get0_name</span>
 <span class="comment">#define EVP_CIPHER_block_size EVP_CIPHER_get_block_size</span>
 <span class="comment">#define EVP_CIPHER_key_length EVP_CIPHER_get_key_length</span>
 <span class="comment">#define EVP_CIPHER_iv_length EVP_CIPHER_get_iv_length</span>
 <span class="comment">#define EVP_CIPHER_flags EVP_CIPHER_get_flags</span>
 <span class="comment">#define EVP_CIPHER_mode EVP_CIPHER_get_mode</span>
 <span class="comment">#define EVP_CIPHER_type EVP_CIPHER_get_type</span>
 <span class="comment">#define EVP_CIPHER_CTX_encrypting EVP_CIPHER_CTX_is_encrypting</span>
 <span class="comment">#define EVP_CIPHER_CTX_nid EVP_CIPHER_CTX_get_nid</span>
 <span class="comment">#define EVP_CIPHER_CTX_block_size EVP_CIPHER_CTX_get_block_size</span>
 <span class="comment">#define EVP_CIPHER_CTX_key_length EVP_CIPHER_CTX_get_key_length</span>
 <span class="comment">#define EVP_CIPHER_CTX_iv_length EVP_CIPHER_CTX_get_iv_length</span>
 <span class="comment">#define EVP_CIPHER_CTX_tag_length EVP_CIPHER_CTX_get_tag_length</span>
 <span class="comment">#define EVP_CIPHER_CTX_num EVP_CIPHER_CTX_get_num</span>
 <span class="comment">#define EVP_CIPHER_CTX_type EVP_CIPHER_CTX_get_type</span>
 <span class="comment">#define EVP_CIPHER_CTX_mode EVP_CIPHER_CTX_get_mode</span>
</pre>
<p>The following function has been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining <strong>OPENSSL_API_COMPAT</strong> with a suitable version value,
see <em>openssl_user_macros(7)</em>:</p>
<pre>
 <span class="variable">const</span> <span class="variable">EVP_CIPHER</span> <span class="variable">*EVP_CIPHER_CTX_cipher</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
</pre>
<p>The following function has been deprecated since OpenSSL 1.1.0, and can be
hidden entirely by defining <strong>OPENSSL_API_COMPAT</strong> with a suitable version value,
see <em>openssl_user_macros(7)</em>:</p>
<pre>
 <span class="keyword">int</span> <span class="variable">EVP_CIPHER_CTX_flags</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">);</span>
</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>The EVP cipher routines are a high-level interface to certain
symmetric ciphers.</p>
<p>The <strong>EVP_CIPHER</strong> type is a structure for cipher method implementation.</p>
<dl>
<dt><strong><a name="evp_cipher_fetch" class="item"><code>EVP_CIPHER_fetch()</code></a></strong></dt>

<dd>
<p>Fetches the cipher implementation for the given <em>algorithm</em> from any provider
offering it, within the criteria given by the <em>properties</em>.
See <em>crypto(7)/ALGORITHM FETCHING</em> for further information.</p>
<p>The returned value must eventually be freed with <a href="#evp_cipher_free"><code>EVP_CIPHER_free()</code></a>.</p>
<p>Fetched <strong>EVP_CIPHER</strong> structures are reference counted.</p>
</dd>
<dt><strong><a name="evp_cipher_up_ref" class="item"><code>EVP_CIPHER_up_ref()</code></a></strong></dt>

<dd>
<p>Increments the reference count for an <strong>EVP_CIPHER</strong> structure.</p>
</dd>
<dt><strong><a name="evp_cipher_free" class="item"><code>EVP_CIPHER_free()</code></a></strong></dt>

<dd>
<p>Decrements the reference count for the fetched <strong>EVP_CIPHER</strong> structure.
If the reference count drops to 0 then the structure is freed.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_new" class="item"><code>EVP_CIPHER_CTX_new()</code></a></strong></dt>

<dd>
<p>Allocates and returns a cipher context.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_free" class="item"><code>EVP_CIPHER_CTX_free()</code></a></strong></dt>

<dd>
<p>Clears all information from a cipher context and frees any allocated memory
associated with it, including <em>ctx</em> itself. This function should be called after
all operations using a cipher are complete so sensitive information does not
remain in memory.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_ctrl" class="item"><code>EVP_CIPHER_CTX_ctrl()</code></a></strong></dt>

<dd>
<p><em>This is a legacy method.</em> <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> and
<a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> is the mechanism that should be used to set and get
parameters that are used by providers.</p>
<p>Performs cipher-specific control actions on context <em>ctx</em>. The control command
is indicated in <em>cmd</em> and any additional arguments in <em>p1</em> and <em>p2</em>.
<a href="#evp_cipher_ctx_ctrl"><code>EVP_CIPHER_CTX_ctrl()</code></a> must be called after EVP_CipherInit_ex2(). Other restrictions
may apply depending on the control type and cipher implementation.</p>
<p>If this function happens to be used with a fetched <strong>EVP_CIPHER</strong>, it will
translate the controls that are known to OpenSSL into <em>OSSL_PARAM(3)</em>
parameters with keys defined by OpenSSL and call <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> or
<a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> as is appropriate for each control command.</p>
<p>See <a href="#controls">CONTROLS</a> below for more information, including what translations are
being done.</p>
</dd>
<dt><strong><a name="evp_cipher_get_params" class="item"><code>EVP_CIPHER_get_params()</code></a></strong></dt>

<dd>
<p>Retrieves the requested list of algorithm <em>params</em> from a CIPHER <em>cipher</em>.
See <a href="#parameters">PARAMETERS</a> below for more information.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_get_params" class="item"><code>EVP_CIPHER_CTX_get_params()</code></a></strong></dt>

<dd>
<p>Retrieves the requested list of <em>params</em> from CIPHER context <em>ctx</em>.
See <a href="#parameters">PARAMETERS</a> below for more information.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_set_params" class="item"><code>EVP_CIPHER_CTX_set_params()</code></a></strong></dt>

<dd>
<p>Sets the list of <em>params</em> into a CIPHER context <em>ctx</em>.
See <a href="#parameters">PARAMETERS</a> below for more information.</p>
</dd>
<dt><strong><a name="evp_cipher_gettable_params" class="item"><code>EVP_CIPHER_gettable_params()</code></a></strong></dt>

<dd>
<p>Get a constant <em>OSSL_PARAM(3)</em> array that describes the retrievable parameters
that can be used with <a href="#evp_cipher_get_params"><code>EVP_CIPHER_get_params()</code></a>.</p>
</dd>
<dt><strong><a name="evp_cipher_gettable_ctx_params" class="item"><code>EVP_CIPHER_gettable_ctx_params()</code> and <code>EVP_CIPHER_CTX_gettable_params()</code></a></strong></dt>

<dd>
<p>Get a constant <em>OSSL_PARAM(3)</em> array that describes the retrievable parameters
that can be used with <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a>.
<a href="#evp_cipher_gettable_ctx_params"><code>EVP_CIPHER_gettable_ctx_params()</code></a> returns the parameters that can be retrieved
from the algorithm, whereas <code>EVP_CIPHER_CTX_gettable_params()</code> returns the
parameters that can be retrieved in the context's current state.</p>
</dd>
<dt><strong><a name="evp_cipher_settable_ctx_params" class="item"><code>EVP_CIPHER_settable_ctx_params()</code> and <code>EVP_CIPHER_CTX_settable_params()</code></a></strong></dt>

<dd>
<p>Get a constant <em>OSSL_PARAM(3)</em> array that describes the settable parameters
that can be used with <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a>.
<a href="#evp_cipher_settable_ctx_params"><code>EVP_CIPHER_settable_ctx_params()</code></a> returns the parameters that can be set from the
algorithm, whereas <code>EVP_CIPHER_CTX_settable_params()</code> returns the parameters that
can be set in the context's current state.</p>
</dd>
<dt><strong><a name="evp_encryptinit_ex2" class="item">EVP_EncryptInit_ex2()</a></strong></dt>

<dd>
<p>Sets up cipher context <em>ctx</em> for encryption with cipher <em>type</em>. <em>type</em> is
typically supplied by calling <a href="#evp_cipher_fetch"><code>EVP_CIPHER_fetch()</code></a>. <em>type</em> may also be set
using legacy functions such as EVP_aes_256_cbc(), but this is not recommended
for new applications. <em>key</em> is the symmetric key to use and <em>iv</em> is the IV to
use (if necessary), the actual number of bytes used for the key and IV depends
on the cipher. The parameters <em>params</em> will be set on the context after
initialisation. It is possible to set all parameters to NULL except <em>type</em> in
an initial call and supply the remaining parameters in subsequent calls, all of
which have <em>type</em> set to NULL. This is done when the default cipher parameters
are not appropriate.
For <strong>EVP_CIPH_GCM_MODE</strong> the IV will be generated internally if it is not
specified.</p>
</dd>
<dt><strong><a name="evp_encryptinit_ex" class="item"><code>EVP_EncryptInit_ex()</code></a></strong></dt>

<dd>
<p>This legacy function is similar to EVP_EncryptInit_ex2() when <em>impl</em> is NULL.
The implementation of the <em>type</em> from the <em>impl</em> engine will be used if it
exists.</p>
</dd>
<dt><strong><a name="evp_encryptupdate" class="item"><code>EVP_EncryptUpdate()</code></a></strong></dt>

<dd>
<p>Encrypts <em>inl</em> bytes from the buffer <em>in</em> and writes the encrypted version to
<em>out</em>. This function can be called multiple times to encrypt successive blocks
of data. The amount of data written depends on the block alignment of the
encrypted data.
For most ciphers and modes, the amount of data written can be anything
from zero bytes to (inl + cipher_block_size - 1) bytes.
For wrap cipher modes, the amount of data written can be anything
from zero bytes to (inl + cipher_block_size) bytes.
For stream ciphers, the amount of data written can be anything from zero
bytes to inl bytes.
Thus, <em>out</em> should contain sufficient room for the operation being performed.
The actual number of bytes written is placed in <em>outl</em>. It also
checks if <em>in</em> and <em>out</em> are partially overlapping, and if they are
0 is returned to indicate failure.</p>
<p>If padding is enabled (the default) then <code>EVP_EncryptFinal_ex()</code> encrypts
the &quot;final&quot; data, that is any data that remains in a partial block.
It uses standard block padding (aka PKCS padding) as described in
the NOTES section, below. The encrypted
final data is written to <em>out</em> which should have sufficient space for
one cipher block. The number of bytes written is placed in <em>outl</em>. After
this function is called the encryption operation is finished and no further
calls to <a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a> should be made.</p>
<p>If padding is disabled then <code>EVP_EncryptFinal_ex()</code> will not encrypt any more
data and it will return an error if any data remains in a partial block:
that is if the total data length is not a multiple of the block size.</p>
</dd>
<dt><strong><a name="evp_decryptinit_ex2" class="item">EVP_DecryptInit_ex2(), <code>EVP_DecryptInit_ex()</code>, <code>EVP_DecryptUpdate()</code>
and <code>EVP_DecryptFinal_ex()</code></a></strong></dt>

<dd>
<p>These functions are the corresponding decryption operations.
<code>EVP_DecryptFinal()</code> will return an error code if padding is enabled and the
final block is not correctly formatted. The parameters and restrictions are
identical to the encryption operations except that if padding is enabled the
decrypted data buffer <em>out</em> passed to <code>EVP_DecryptUpdate()</code> should have
sufficient room for (<em>inl</em> + cipher_block_size) bytes unless the cipher block
size is 1 in which case <em>inl</em> bytes is sufficient.</p>
</dd>
<dt><strong><a name="evp_cipherinit_ex2" class="item">EVP_CipherInit_ex2(), <code>EVP_CipherInit_ex()</code>, <code>EVP_CipherUpdate()</code> and
<code>EVP_CipherFinal_ex()</code></a></strong></dt>

<dd>
<p>These functions can be used for decryption or encryption. The operation
performed depends on the value of the <em>enc</em> parameter. It should be set to 1
for encryption, 0 for decryption and -1 to leave the value unchanged
(the actual value of 'enc' being supplied in a previous call).</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_reset" class="item"><code>EVP_CIPHER_CTX_reset()</code></a></strong></dt>

<dd>
<p>Clears all information from a cipher context and free up any allocated memory
associated with it, except the <em>ctx</em> itself. This function should be called
anytime <em>ctx</em> is reused by another
<code>EVP_CipherInit()</code> / <code>EVP_CipherUpdate()</code> / <code>EVP_CipherFinal()</code> series of calls.</p>
</dd>
<dt><strong><a name="evp_encryptinit" class="item"><code>EVP_EncryptInit()</code>, <code>EVP_DecryptInit()</code> and <code>EVP_CipherInit()</code></a></strong></dt>

<dd>
<p>Behave in a similar way to <a href="#evp_encryptinit_ex"><code>EVP_EncryptInit_ex()</code></a>, <code>EVP_DecryptInit_ex()</code> and
<code>EVP_CipherInit_ex()</code> except if the <em>type</em> is not a fetched cipher they use the
default implementation of the <em>type</em>.</p>
</dd>
<dt><strong><a name="evp_encryptfinal" class="item"><code>EVP_EncryptFinal()</code>, <code>EVP_DecryptFinal()</code> and <code>EVP_CipherFinal()</code></a></strong></dt>

<dd>
<p>Identical to <code>EVP_EncryptFinal_ex()</code>, <code>EVP_DecryptFinal_ex()</code> and
<code>EVP_CipherFinal_ex()</code>. In previous releases they also cleaned up
the <em>ctx</em>, but this is no longer done and <code>EVP_CIPHER_CTX_cleanup()</code>
must be called to free any context resources.</p>
</dd>
<dt><strong><a name="evp_cipher" class="item"><code>EVP_Cipher()</code></a></strong></dt>

<dd>
<p>Encrypts or decrypts a maximum <em>inl</em> amount of bytes from <em>in</em> and leaves the
result in <em>out</em>.</p>
<p>For legacy ciphers - If the cipher doesn't have the flag
<strong>EVP_CIPH_FLAG_CUSTOM_CIPHER</strong> set, then <em>inl</em> must be a multiple of
<a href="#evp_cipher_get_block_size"><code>EVP_CIPHER_get_block_size()</code></a>.  If it isn't, the result is undefined.  If the cipher
has that flag set, then <em>inl</em> can be any size.</p>
<p>Due to the constraints of the API contract of this function it shouldn't be used
in applications, please consider using <code>EVP_CipherUpdate()</code> and
<code>EVP_CipherFinal_ex()</code> instead.</p>
</dd>
<dt><strong><a name="evp_get_cipherbyname" class="item"><code>EVP_get_cipherbyname()</code>, <code>EVP_get_cipherbynid()</code> and <code>EVP_get_cipherbyobj()</code></a></strong></dt>

<dd>
<p>Returns an <strong>EVP_CIPHER</strong> structure when passed a cipher name, a cipher <strong>NID</strong> or
an <strong>ASN1_OBJECT</strong> structure respectively.</p>
<p><a href="#evp_get_cipherbyname"><code>EVP_get_cipherbyname()</code></a> will return NULL for algorithms such as &quot;AES-128-SIV&quot;,
&quot;AES-128-CBC-CTS&quot; and &quot;CAMELLIA-128-CBC-CTS&quot; which were previously only
accessible via low level interfaces.</p>
<p>The <a href="#evp_get_cipherbyname"><code>EVP_get_cipherbyname()</code></a> function is present for backwards compatibility with
OpenSSL prior to version 3 and is different to the <a href="#evp_cipher_fetch"><code>EVP_CIPHER_fetch()</code></a> function
since it does not attempt to &quot;fetch&quot; an implementation of the cipher.
Additionally, it only knows about ciphers that are built-in to OpenSSL and have
an associated NID. Similarly <code>EVP_get_cipherbynid()</code> and <code>EVP_get_cipherbyobj()</code>
also return objects without an associated implementation.</p>
<p>When the cipher objects returned by these functions are used (such as in a call
to EVP_EncryptInit_ex()) an implementation of the cipher will be implicitly
fetched from the loaded providers. This fetch could fail if no suitable
implementation is available. Use <a href="#evp_cipher_fetch"><code>EVP_CIPHER_fetch()</code></a> instead to explicitly fetch
the algorithm and an associated implementation from a provider.</p>
<p>See <em>crypto(7)/ALGORITHM FETCHING</em> for more information about fetching.</p>
<p>The cipher objects returned from these functions do not need to be freed with
<a href="#evp_cipher_free"><code>EVP_CIPHER_free()</code></a>.</p>
</dd>
<dt><strong><a name="evp_cipher_get_nid" class="item"><code>EVP_CIPHER_get_nid()</code> and <code>EVP_CIPHER_CTX_get_nid()</code></a></strong></dt>

<dd>
<p>Return the NID of a cipher when passed an <strong>EVP_CIPHER</strong> or <strong>EVP_CIPHER_CTX</strong>
structure.  The actual NID value is an internal value which may not have a
corresponding OBJECT IDENTIFIER.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_set_flags" class="item"><code>EVP_CIPHER_CTX_set_flags()</code>, <code>EVP_CIPHER_CTX_clear_flags()</code> and <code>EVP_CIPHER_CTX_test_flags()</code></a></strong></dt>

<dd>
<p>Sets, clears and tests <em>ctx</em> flags.  See <a href="#flags">FLAGS</a> below for more information.</p>
<p>For provided ciphers <a href="#evp_cipher_ctx_set_flags"><code>EVP_CIPHER_CTX_set_flags()</code></a> should be called only after the
fetched cipher has been assigned to the <em>ctx</em>. It is recommended to use
<a href="#parameters">PARAMETERS</a> instead.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_set_padding" class="item"><code>EVP_CIPHER_CTX_set_padding()</code></a></strong></dt>

<dd>
<p>Enables or disables padding. This function should be called after the context
is set up for encryption or decryption with EVP_EncryptInit_ex2(),
EVP_DecryptInit_ex2() or EVP_CipherInit_ex2(). By default encryption operations
are padded using standard block padding and the padding is checked and removed
when decrypting. If the <em>pad</em> parameter is zero then no padding is
performed, the total amount of data encrypted or decrypted must then
be a multiple of the block size or an error will occur.</p>
</dd>
<dt><strong><a name="evp_cipher_get_key_length" class="item"><code>EVP_CIPHER_get_key_length()</code> and <code>EVP_CIPHER_CTX_get_key_length()</code></a></strong></dt>

<dd>
<p>Return the key length of a cipher when passed an <strong>EVP_CIPHER</strong> or
<strong>EVP_CIPHER_CTX</strong> structure. The constant <strong>EVP_MAX_KEY_LENGTH</strong> is the maximum
key length for all ciphers. Note: although <a href="#evp_cipher_get_key_length"><code>EVP_CIPHER_get_key_length()</code></a> is fixed for
a given cipher, the value of <code>EVP_CIPHER_CTX_get_key_length()</code> may be different for
variable key length ciphers.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_set_key_length" class="item"><code>EVP_CIPHER_CTX_set_key_length()</code></a></strong></dt>

<dd>
<p>Sets the key length of the cipher context.
If the cipher is a fixed length cipher then attempting to set the key
length to any value other than the fixed value is an error.</p>
</dd>
<dt><strong><a name="evp_cipher_get_iv_length" class="item"><code>EVP_CIPHER_get_iv_length()</code> and <code>EVP_CIPHER_CTX_get_iv_length()</code></a></strong></dt>

<dd>
<p>Return the IV length of a cipher when passed an <strong>EVP_CIPHER</strong> or
<strong>EVP_CIPHER_CTX</strong>. It will return zero if the cipher does not use an IV.
The constant <strong>EVP_MAX_IV_LENGTH</strong> is the maximum IV length for all ciphers.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_get_tag_length" class="item"><code>EVP_CIPHER_CTX_get_tag_length()</code></a></strong></dt>

<dd>
<p>Returns the tag length of an AEAD cipher when passed a <strong>EVP_CIPHER_CTX</strong>. It will
return zero if the cipher does not support a tag. It returns a default value if
the tag length has not been set.</p>
</dd>
<dt><strong><a name="evp_cipher_get_block_size" class="item"><code>EVP_CIPHER_get_block_size()</code> and <code>EVP_CIPHER_CTX_get_block_size()</code></a></strong></dt>

<dd>
<p>Return the block size of a cipher when passed an <strong>EVP_CIPHER</strong> or
<strong>EVP_CIPHER_CTX</strong> structure. The constant <strong>EVP_MAX_BLOCK_LENGTH</strong> is also the
maximum block length for all ciphers.</p>
</dd>
<dt><strong><a name="evp_cipher_get_type" class="item"><code>EVP_CIPHER_get_type()</code> and <code>EVP_CIPHER_CTX_get_type()</code></a></strong></dt>

<dd>
<p>Return the type of the passed cipher or context. This &quot;type&quot; is the actual NID
of the cipher OBJECT IDENTIFIER and as such it ignores the cipher parameters
(40 bit RC2 and 128 bit RC2 have the same NID). If the cipher does not have an
object identifier or does not have ASN1 support this function will return
<strong>NID_undef</strong>.</p>
</dd>
<dt><strong><a name="evp_cipher_is_a" class="item"><code>EVP_CIPHER_is_a()</code></a></strong></dt>

<dd>
<p>Returns 1 if <em>cipher</em> is an implementation of an algorithm that's identifiable
with <em>name</em>, otherwise 0. If <em>cipher</em> is a legacy cipher (it's the return
value from the likes of EVP_aes128() rather than the result of an
EVP_CIPHER_fetch()), only cipher names registered with the default library
context (see <em>OSSL_LIB_CTX(3)</em>) will be considered.</p>
</dd>
<dt><strong><a name="evp_cipher_get0_name" class="item">EVP_CIPHER_get0_name() and EVP_CIPHER_CTX_get0_name()</a></strong></dt>

<dd>
<p>Return the name of the passed cipher or context.  For fetched ciphers with
multiple names, only one of them is returned. See also <a href="#evp_cipher_names_do_all"><code>EVP_CIPHER_names_do_all()</code></a>.</p>
</dd>
<dt><strong><a name="evp_cipher_names_do_all" class="item"><code>EVP_CIPHER_names_do_all()</code></a></strong></dt>

<dd>
<p>Traverses all names for the <em>cipher</em>, and calls <em>fn</em> with each name and
<em>data</em>.  This is only useful with fetched <strong>EVP_CIPHER</strong>s.</p>
</dd>
<dt><strong><a name="evp_cipher_get0_description" class="item">EVP_CIPHER_get0_description()</a></strong></dt>

<dd>
<p>Returns a description of the cipher, meant for display and human consumption.
The description is at the discretion of the cipher implementation.</p>
</dd>
<dt><strong><a name="evp_cipher_get0_provider" class="item">EVP_CIPHER_get0_provider()</a></strong></dt>

<dd>
<p>Returns an <strong>OSSL_PROVIDER</strong> pointer to the provider that implements the given
<strong>EVP_CIPHER</strong>.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_get0_cipher" class="item">EVP_CIPHER_CTX_get0_cipher()</a></strong></dt>

<dd>
<p>Returns the <strong>EVP_CIPHER</strong> structure when passed an <strong>EVP_CIPHER_CTX</strong> structure.
EVP_CIPHER_CTX_get1_cipher() is the same except the ownership is passed to
the caller.</p>
</dd>
<dt><strong><a name="evp_cipher_get_mode" class="item"><code>EVP_CIPHER_get_mode()</code> and <code>EVP_CIPHER_CTX_get_mode()</code></a></strong></dt>

<dd>
<p>Return the block cipher mode:
EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE, EVP_CIPH_OFB_MODE,
EVP_CIPH_CTR_MODE, EVP_CIPH_GCM_MODE, EVP_CIPH_CCM_MODE, EVP_CIPH_XTS_MODE,
EVP_CIPH_WRAP_MODE, EVP_CIPH_OCB_MODE or EVP_CIPH_SIV_MODE.
If the cipher is a stream cipher then EVP_CIPH_STREAM_CIPHER is returned.</p>
</dd>
<dt><strong><a name="evp_cipher_get_flags" class="item"><code>EVP_CIPHER_get_flags()</code></a></strong></dt>

<dd>
<p>Returns any flags associated with the cipher. See <a href="#flags">FLAGS</a>
for a list of currently defined flags.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_get_num" class="item"><code>EVP_CIPHER_CTX_get_num()</code> and <code>EVP_CIPHER_CTX_set_num()</code></a></strong></dt>

<dd>
<p>Gets or sets the cipher specific &quot;num&quot; parameter for the associated <em>ctx</em>.
Built-in ciphers typically use this to track how much of the current underlying block
has been &quot;used&quot; already.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_is_encrypting" class="item"><code>EVP_CIPHER_CTX_is_encrypting()</code></a></strong></dt>

<dd>
<p>Reports whether the <em>ctx</em> is being used for encryption or decryption.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_flags" class="item"><code>EVP_CIPHER_CTX_flags()</code></a></strong></dt>

<dd>
<p>A deprecated macro calling <a href="#evp_cipher_get_flags"><code>EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))</code></a>.
Do not use.</p>
</dd>
<dt><strong><a name="evp_cipher_param_to_asn1" class="item">EVP_CIPHER_param_to_asn1()</a></strong></dt>

<dd>
<p>Sets the AlgorithmIdentifier &quot;parameter&quot; based on the passed cipher. This will
typically include any parameters and an IV. The cipher IV (if any) must be set
when this call is made. This call should be made before the cipher is actually
&quot;used&quot; (before any <a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a>, <code>EVP_DecryptUpdate()</code> calls for example).
This function may fail if the cipher does not have any ASN1 support.</p>
</dd>
<dt><strong><a name="evp_cipher_asn1_to_param" class="item">EVP_CIPHER_asn1_to_param()</a></strong></dt>

<dd>
<p>Sets the cipher parameters based on an ASN1 AlgorithmIdentifier &quot;parameter&quot;.
The precise effect depends on the cipher. In the case of <strong>RC2</strong>, for example,
it will set the IV and effective key length.
This function should be called after the base cipher type is set but before
the key is set. For example <code>EVP_CipherInit()</code> will be called with the IV and
key set to NULL, EVP_CIPHER_asn1_to_param() will be called and finally
<code>EVP_CipherInit()</code> again with all parameters except the key set to NULL. It is
possible for this function to fail if the cipher does not have any ASN1 support
or the parameters cannot be set (for example the RC2 effective key length
is not supported.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_rand_key" class="item"><code>EVP_CIPHER_CTX_rand_key()</code></a></strong></dt>

<dd>
<p>Generates a random key of the appropriate length based on the cipher context.
The <strong>EVP_CIPHER</strong> can provide its own random key generation routine to support
keys of a specific form. <em>key</em> must point to a buffer at least as big as the
value returned by <code>EVP_CIPHER_CTX_get_key_length()</code>.</p>
</dd>
<dt><strong><a name="evp_cipher_do_all_provided" class="item"><code>EVP_CIPHER_do_all_provided()</code></a></strong></dt>

<dd>
<p>Traverses all ciphers implemented by all activated providers in the given
library context <em>libctx</em>, and for each of the implementations, calls the given
function <em>fn</em> with the implementation method and the given <em>arg</em> as argument.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="parameters">PARAMETERS</a></h1>
<p>See <em>OSSL_PARAM(3)</em> for information about passing parameters.</p>
<p>
</p>
<h2><a name="gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a></h2>
<p>When <a href="#evp_cipher_fetch"><code>EVP_CIPHER_fetch()</code></a> is called it internally calls <a href="#evp_cipher_get_params"><code>EVP_CIPHER_get_params()</code></a>
and caches the results.</p>
<p><a href="#evp_cipher_get_params"><code>EVP_CIPHER_get_params()</code></a> can be used with the following <em>OSSL_PARAM(3)</em> keys:</p>
<dl>
<dt><strong><a name="mode_ossl_cipher_param_mode_unsigned_integer" class="item">&quot;mode&quot; (<strong>OSSL_CIPHER_PARAM_MODE</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the mode for the associated cipher algorithm <em>cipher</em>.
See <a href="#evp_cipher_get_mode">EVP_CIPHER_get_mode() and EVP_CIPHER_CTX_get_mode()</a> for a list of valid modes.
Use <a href="#evp_cipher_get_mode"><code>EVP_CIPHER_get_mode()</code></a> to retrieve the cached value.</p>
</dd>
<dt><strong><a name="keylen_ossl_cipher_param_keylen_unsigned_integer" class="item">&quot;keylen&quot; (<strong>OSSL_CIPHER_PARAM_KEYLEN</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the key length for the associated cipher algorithm <em>cipher</em>.
Use <a href="#evp_cipher_get_key_length"><code>EVP_CIPHER_get_key_length()</code></a> to retrieve the cached value.</p>
</dd>
<dt><strong><a name="ivlen_ossl_cipher_param_ivlen_unsigned_integer" class="item">&quot;ivlen&quot; (<strong>OSSL_CIPHER_PARAM_IVLEN</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the IV length for the associated cipher algorithm <em>cipher</em>.
Use <a href="#evp_cipher_get_iv_length"><code>EVP_CIPHER_get_iv_length()</code></a> to retrieve the cached value.</p>
</dd>
<dt><strong><a name="blocksize_ossl_cipher_param_block_size_unsigned_integer" class="item">&quot;blocksize&quot; (<strong>OSSL_CIPHER_PARAM_BLOCK_SIZE</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the block size for the associated cipher algorithm <em>cipher</em>.
The block size should be 1 for stream ciphers.
Note that the block size for a cipher may be different to the block size for
the underlying encryption/decryption primitive.
For example AES in CTR mode has a block size of 1 (because it operates like a
stream cipher), even though AES has a block size of 16.
Use <a href="#evp_cipher_get_block_size"><code>EVP_CIPHER_get_block_size()</code></a> to retrieve the cached value.</p>
</dd>
<dt><strong><a name="aead_ossl_cipher_param_aead_integer" class="item">&quot;aead&quot; (<strong>OSSL_CIPHER_PARAM_AEAD</strong>) &lt;integer&gt;</a></strong></dt>

<dd>
<p>Gets 1 if this is an AEAD cipher algorithm, otherwise it gets 0.
Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) to retrieve the
cached value.</p>
</dd>
<dt><strong><a name="custom_iv_ossl_cipher_param_custom_iv_integer" class="item">&quot;custom-iv&quot; (<strong>OSSL_CIPHER_PARAM_CUSTOM_IV</strong>) &lt;integer&gt;</a></strong></dt>

<dd>
<p>Gets 1 if the cipher algorithm <em>cipher</em> has a custom IV, otherwise it gets 0.
Storing and initializing the IV is left entirely to the implementation, if a
custom IV is used.
Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_CUSTOM_IV) to retrieve the
cached value.</p>
</dd>
<dt><strong><a name="cts_ossl_cipher_param_cts_integer" class="item">&quot;cts&quot; (<strong>OSSL_CIPHER_PARAM_CTS</strong>) &lt;integer&gt;</a></strong></dt>

<dd>
<p>Gets 1 if the cipher algorithm <em>cipher</em> uses ciphertext stealing,
otherwise it gets 0.
This is currently used to indicate that the cipher is a one shot that only
allows a single call to <code>EVP_CipherUpdate()</code>.
Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_CTS) to retrieve the
cached value.</p>
</dd>
<dt><strong><a name="tls_multi_ossl_cipher_param_tls1_multiblock_integer" class="item">&quot;tls-multi&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK</strong>) &lt;integer&gt;</a></strong></dt>

<dd>
<p>Gets 1 if the cipher algorithm <em>cipher</em> supports interleaving of crypto blocks,
otherwise it gets 0. The interleaving is an optimization only applicable to certain
TLS ciphers.
Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) to retrieve the
cached value.</p>
</dd>
<dt><strong><a name="has_randkey_ossl_cipher_param_has_randkey_integer" class="item">&quot;has-randkey&quot; (<strong>OSSL_CIPHER_PARAM_HAS_RANDKEY</strong>) &lt;integer&gt;</a></strong></dt>

<dd>
<p>Gets 1 if the cipher algorithm <em>cipher</em> supports the gettable EVP_CIPHER_CTX
parameter <strong>OSSL_CIPHER_PARAM_RANDOM_KEY</strong>. Only DES and 3DES set this to 1,
all other OpenSSL ciphers return 0.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="gettable_and_settable_evp_cipher_ctx_parameters">Gettable and Settable EVP_CIPHER_CTX parameters</a></h2>
<p>The following <em>OSSL_PARAM(3)</em> keys can be used with both <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a>
and <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a>.</p>
<dl>
<dt><strong><a name="padding_ossl_cipher_param_padding_unsigned_integer" class="item">&quot;padding&quot; (<strong>OSSL_CIPHER_PARAM_PADDING</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets or sets the padding mode for the cipher context <em>ctx</em>.
Padding is enabled if the value is 1, and disabled if the value is 0.
See also <a href="#evp_cipher_ctx_set_padding"><code>EVP_CIPHER_CTX_set_padding()</code></a>.</p>
</dd>
<dt><strong><a name="num_ossl_cipher_param_num_unsigned_integer" class="item">&quot;num&quot; (<strong>OSSL_CIPHER_PARAM_NUM</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets or sets the cipher specific &quot;num&quot; parameter for the cipher context <em>ctx</em>.
Built-in ciphers typically use this to track how much of the current underlying
block has been &quot;used&quot; already.
See also <a href="#evp_cipher_ctx_get_num"><code>EVP_CIPHER_CTX_get_num()</code></a> and <code>EVP_CIPHER_CTX_set_num()</code>.</p>
</dd>
<dt><strong><a name="keylen_ossl_cipher_param_keylen_unsigned_integer2" class="item">&quot;keylen&quot; (<strong>OSSL_CIPHER_PARAM_KEYLEN</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets or sets the key length for the cipher context <em>ctx</em>.
The length of the &quot;keylen&quot; parameter should not exceed that of a <strong>size_t</strong>.
See also <code>EVP_CIPHER_CTX_get_key_length()</code> and <a href="#evp_cipher_ctx_set_key_length"><code>EVP_CIPHER_CTX_set_key_length()</code></a>.</p>
</dd>
<dt><strong><a name="tag_ossl_cipher_param_aead_tag_octet_string" class="item">&quot;tag&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TAG</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Gets or sets the AEAD tag for the associated cipher context <em>ctx</em>.
See <em>EVP_EncryptInit(3)/AEAD Interface</em>.</p>
</dd>
<dt><strong><a name="keybits_ossl_cipher_param_rc2_keybits_unsigned_integer" class="item">&quot;keybits&quot; (<strong>OSSL_CIPHER_PARAM_RC2_KEYBITS</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets or sets the effective keybits used for a RC2 cipher.
The length of the &quot;keybits&quot; parameter should not exceed that of a <strong>size_t</strong>.</p>
</dd>
<dt><strong><a name="rounds_ossl_cipher_param_rounds_unsigned_integer" class="item">&quot;rounds&quot; (<strong>OSSL_CIPHER_PARAM_ROUNDS</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets or sets the number of rounds to be used for a cipher.
This is used by the RC5 cipher.</p>
</dd>
<dt><strong><a name="alg_id_param_ossl_cipher_param_algorithm_id_params_octet_string" class="item">&quot;alg_id_param&quot; (<strong>OSSL_CIPHER_PARAM_ALGORITHM_ID_PARAMS</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Used to pass the DER encoded AlgorithmIdentifier parameter to or from
the cipher implementation.  Functions like <a href="#evp_cipher_param_to_asn1">EVP_CIPHER_param_to_asn1(3)</a>
and <a href="#evp_cipher_asn1_to_param">EVP_CIPHER_asn1_to_param(3)</a> use this parameter for any implementation
that has the flag <strong>EVP_CIPH_FLAG_CUSTOM_ASN1</strong> set.</p>
</dd>
<dt><strong><a name="cts_mode_ossl_cipher_param_cts_mode_utf8_string" class="item">&quot;cts_mode&quot; (<strong>OSSL_CIPHER_PARAM_CTS_MODE</strong>) &lt;UTF8 string&gt;</a></strong></dt>

<dd>
<p>Gets or sets the cipher text stealing mode. For all modes the output size is the
same as the input size. The input length must be greater than or equal to the
block size. (The block size for AES and CAMELLIA is 16 bytes).</p>
<p>Valid values for the mode are:</p>
<dl>
<dt><strong><a name="cs1" class="item">&quot;CS1&quot;</a></strong></dt>

<dd>
<p>The NIST variant of cipher text stealing.
For input lengths that are multiples of the block size it is equivalent to
using a &quot;AES-XXX-CBC&quot; or &quot;CAMELLIA-XXX-CBC&quot; cipher otherwise the second last
cipher text block is a partial block.</p>
</dd>
<dt><strong><a name="cs2" class="item">&quot;CS2&quot;</a></strong></dt>

<dd>
<p>For input lengths that are multiples of the block size it is equivalent to
using a &quot;AES-XXX-CBC&quot; or &quot;CAMELLIA-XXX-CBC&quot; cipher, otherwise it is the same as
&quot;CS3&quot; mode.</p>
</dd>
<dt><strong><a name="cs3" class="item">&quot;CS3&quot;</a></strong></dt>

<dd>
<p>The Kerberos5 variant of cipher text stealing which always swaps the last
cipher text block with the previous block (which may be a partial or full block
depending on the input length). If the input length is exactly one full block
then this is equivalent to using a &quot;AES-XXX-CBC&quot; or &quot;CAMELLIA-XXX-CBC&quot; cipher.</p>
</dd>
</dl>
<p>The default is &quot;CS1&quot;.
This is only supported for &quot;AES-128-CBC-CTS&quot;, &quot;AES-192-CBC-CTS&quot;, &quot;AES-256-CBC-CTS&quot;,
&quot;CAMELLIA-128-CBC-CTS&quot;, &quot;CAMELLIA-192-CBC-CTS&quot; and &quot;CAMELLIA-256-CBC-CTS&quot;.</p>
</dd>
<dt><strong><a name="tls1multi_interleave_ossl_cipher_param_tls1_multiblock_interleave_unsigned_integer" class="item">&quot;tls1multi_interleave&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Sets or gets the number of records being sent in one go for a tls1 multiblock
cipher operation (either 4 or 8 records).</p>
</dd>
</dl>
<p>
</p>
<h2><a name="gettable_evp_cipher_ctx_parameters">Gettable EVP_CIPHER_CTX parameters</a></h2>
<p>The following <em>OSSL_PARAM(3)</em> keys can be used with EVP_CIPHER_CTX_get_params():</p>
<dl>
<dt><strong><a name="ivlen_ossl_cipher_param_ivlen_and_ossl_cipher_param_aead_ivlen_unsigned_integer" class="item">&quot;ivlen&quot; (<strong>OSSL_CIPHER_PARAM_IVLEN</strong> and &lt;<strong>OSSL_CIPHER_PARAM_AEAD_IVLEN</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the IV length for the cipher context <em>ctx</em>.
The length of the &quot;ivlen&quot; parameter should not exceed that of a <strong>size_t</strong>.
See also <code>EVP_CIPHER_CTX_get_iv_length()</code>.</p>
</dd>
<dt><strong><a name="iv_ossl_cipher_param_iv_octet_string_or_octet_ptr" class="item">&quot;iv&quot; (<strong>OSSL_CIPHER_PARAM_IV</strong>) &lt;octet string OR octet ptr&gt;</a></strong></dt>

<dd>
<p>Gets the IV used to initialize the associated cipher context <em>ctx</em>.
See also <code>EVP_CIPHER_CTX_get_original_iv()</code>.</p>
</dd>
<dt><strong><a name="updated_iv_ossl_cipher_param_updated_iv_octet_string_or_octet_ptr" class="item">&quot;updated-iv&quot; (<strong>OSSL_CIPHER_PARAM_UPDATED_IV</strong>) &lt;octet string OR octet ptr&gt;</a></strong></dt>

<dd>
<p>Gets the updated pseudo-IV state for the associated cipher context, e.g.,
the previous ciphertext block for CBC mode or the iteratively encrypted IV
value for OFB mode.  Note that octet pointer access is deprecated and is
provided only for backwards compatibility with historical libcrypto APIs.
See also <code>EVP_CIPHER_CTX_get_updated_iv()</code>.</p>
</dd>
<dt><strong><a name="randkey_ossl_cipher_param_random_key_octet_string" class="item">&quot;randkey&quot; (<strong>OSSL_CIPHER_PARAM_RANDOM_KEY</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Gets an implementation specific randomly generated key for the associated
cipher context <em>ctx</em>. This is currently only supported by DES and 3DES (which set
the key to odd parity).</p>
</dd>
<dt><strong><a name="taglen_ossl_cipher_param_aead_taglen_unsigned_integer" class="item">&quot;taglen&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TAGLEN</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the tag length to be used for an AEAD cipher for the associated cipher
context <em>ctx</em>. It gets a default value if it has not been set.
The length of the &quot;taglen&quot; parameter should not exceed that of a <strong>size_t</strong>.
See also <a href="#evp_cipher_ctx_get_tag_length"><code>EVP_CIPHER_CTX_get_tag_length()</code></a>.</p>
</dd>
<dt><strong><a name="tlsaadpad_ossl_cipher_param_aead_tls1_aad_pad_unsigned_integer" class="item">&quot;tlsaadpad&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the length of the tag that will be added to a TLS record for the AEAD
tag for the associated cipher context <em>ctx</em>.
The length of the &quot;tlsaadpad&quot; parameter should not exceed that of a <strong>size_t</strong>.</p>
</dd>
<dt><strong><a name="tlsivgen_ossl_cipher_param_aead_tls1_get_iv_gen_octet_string" class="item">&quot;tlsivgen&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_GET_IV_GEN</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Gets the invocation field generated for encryption.
Can only be called after &quot;tlsivfixed&quot; is set.
This is only used for GCM mode.</p>
</dd>
<dt><strong><a name="tls1multi_enclen_ossl_cipher_param_tls1_multiblock_enc_len_unsigned_integer" class="item">&quot;tls1multi_enclen&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Get the total length of the record returned from the &quot;tls1multi_enc&quot; operation.</p>
</dd>
<dt><strong><a name="tls1multi_maxbufsz_ossl_cipher_param_tls1_multiblock_max_bufsize_unsigned_integer" class="item">&quot;tls1multi_maxbufsz&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the maximum record length for a TLS1 multiblock cipher operation.
The length of the &quot;tls1multi_maxbufsz&quot; parameter should not exceed that of a <strong>size_t</strong>.</p>
</dd>
<dt><strong><a name="tls1multi_aadpacklen_ossl_cipher_param_tls1_multiblock_aad_packlen_unsigned_integer" class="item">&quot;tls1multi_aadpacklen&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Gets the result of running the &quot;tls1multi_aad&quot; operation.</p>
</dd>
<dt><strong><a name="tls_mac_ossl_cipher_param_tls_mac_octet_ptr" class="item">&quot;tls-mac&quot; (<strong>OSSL_CIPHER_PARAM_TLS_MAC</strong>) &lt;octet ptr&gt;</a></strong></dt>

<dd>
<p>Used to pass the TLS MAC data.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="settable_evp_cipher_ctx_parameters">Settable EVP_CIPHER_CTX parameters</a></h2>
<p>The following <em>OSSL_PARAM(3)</em> keys can be used with EVP_CIPHER_CTX_set_params():</p>
<dl>
<dt><strong><a name="mackey_ossl_cipher_param_aead_mac_key_octet_string" class="item">&quot;mackey&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_MAC_KEY</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Sets the MAC key used by composite AEAD ciphers such as AES-CBC-HMAC-SHA256.</p>
</dd>
<dt><strong><a name="speed_ossl_cipher_param_speed_unsigned_integer" class="item">&quot;speed&quot; (<strong>OSSL_CIPHER_PARAM_SPEED</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Sets the speed option for the associated cipher context. This is only supported
by AES SIV ciphers which disallow multiple operations by default.
Setting &quot;speed&quot; to 1 allows another encrypt or decrypt operation to be
performed. This is used for performance testing.</p>
</dd>
<dt><strong><a name="use_bits_ossl_cipher_param_use_bits_unsigned_integer" class="item">&quot;use-bits&quot; (<strong>OSSL_CIPHER_PARAM_USE_BITS</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Determines if the input length <em>inl</em> passed to <a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a>,
<code>EVP_DecryptUpdate()</code> and <code>EVP_CipherUpdate()</code> is the number of bits or number of bytes.
Setting &quot;use-bits&quot; to 1 uses bits. The default is in bytes.
This is only used for <strong>CFB1</strong> ciphers.</p>
<p>This can be set using EVP_CIPHER_CTX_set_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS).</p>
</dd>
<dt><strong><a name="tls_version_ossl_cipher_param_tls_version_integer" class="item">&quot;tls-version&quot; (<strong>OSSL_CIPHER_PARAM_TLS_VERSION</strong>) &lt;integer&gt;</a></strong></dt>

<dd>
<p>Sets the TLS version.</p>
</dd>
<dt><strong><a name="tls_mac_size_ossl_cipher_param_tls_mac_size_unsigned_integer" class="item">&quot;tls-mac-size&quot; (<strong>OSSL_CIPHER_PARAM_TLS_MAC_SIZE</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Set the TLS MAC size.</p>
</dd>
<dt><strong><a name="tlsaad_ossl_cipher_param_aead_tls1_aad_octet_string" class="item">&quot;tlsaad&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Sets TLSv1.2 AAD information for the associated cipher context <em>ctx</em>.
TLSv1.2 AAD information is always 13 bytes in length and is as defined for the
&quot;additional_data&quot; field described in section 6.2.3.3 of <a href="http://www.ietf.org/rfc/rfc5246.txt" class="rfc">RFC5246</a>.</p>
</dd>
<dt><strong><a name="tlsivfixed_ossl_cipher_param_aead_tls1_iv_fixed_octet_string" class="item">&quot;tlsivfixed&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_IV_FIXED</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Sets the fixed portion of an IV for an AEAD cipher used in a TLS record
encryption/ decryption for the associated cipher context.
TLS record encryption/decryption always occurs &quot;in place&quot; so that the input and
output buffers are always the same memory location.
AEAD IVs in TLSv1.2 consist of an implicit &quot;fixed&quot; part and an explicit part
that varies with every record.
Setting a TLS fixed IV changes a cipher to encrypt/decrypt TLS records.
TLS records are encrypted/decrypted using a single OSSL_FUNC_cipher_cipher call per
record.
For a record decryption the first bytes of the input buffer will be the explicit
part of the IV and the final bytes of the input buffer will be the AEAD tag.
The length of the explicit part of the IV and the tag length will depend on the
cipher in use and will be defined in the RFC for the relevant ciphersuite.
In order to allow for &quot;in place&quot; decryption the plaintext output should be
written to the same location in the output buffer that the ciphertext payload
was read from, i.e. immediately after the explicit IV.</p>
<p>When encrypting a record the first bytes of the input buffer should be empty to
allow space for the explicit IV, as will the final bytes where the tag will
be written.
The length of the input buffer will include the length of the explicit IV, the
payload, and the tag bytes.
The cipher implementation should generate the explicit IV and write it to the
beginning of the output buffer, do &quot;in place&quot; encryption of the payload and
write that to the output buffer, and finally add the tag onto the end of the
output buffer.</p>
<p>Whether encrypting or decrypting the value written to <em>*outl</em> in the
OSSL_FUNC_cipher_cipher call should be the length of the payload excluding the explicit
IV length and the tag length.</p>
</dd>
<dt><strong><a name="tlsivinv_ossl_cipher_param_aead_tls1_set_iv_inv_octet_string" class="item">&quot;tlsivinv&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_SET_IV_INV</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Sets the invocation field used for decryption.
Can only be called after &quot;tlsivfixed&quot; is set.
This is only used for GCM mode.</p>
</dd>
<dt><strong><a name="tls1multi_enc_ossl_cipher_param_tls1_multiblock_enc_octet_string" class="item">&quot;tls1multi_enc&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Triggers a multiblock TLS1 encrypt operation for a TLS1 aware cipher that
supports sending 4 or 8 records in one go.
The cipher performs both the MAC and encrypt stages and constructs the record
headers itself.
&quot;tls1multi_enc&quot; supplies the output buffer for the encrypt operation,
&quot;tls1multi_encin&quot; &amp; &quot;tls1multi_interleave&quot; must also be set in order to supply
values to the encrypt operation.</p>
</dd>
<dt><strong><a name="tls1multi_encin_ossl_cipher_param_tls1_multiblock_enc_in_octet_string" class="item">&quot;tls1multi_encin&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Supplies the data to encrypt for a TLS1 multiblock cipher operation.</p>
</dd>
<dt><strong><a name="tls1multi_maxsndfrag_ossl_cipher_param_tls1_multiblock_max_send_fragment_unsigned_integer" class="item">&quot;tls1multi_maxsndfrag&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT</strong>) &lt;unsigned integer&gt;</a></strong></dt>

<dd>
<p>Sets the maximum send fragment size for a TLS1 multiblock cipher operation.
It must be set before using &quot;tls1multi_maxbufsz&quot;.
The length of the &quot;tls1multi_maxsndfrag&quot; parameter should not exceed that of a <strong>size_t</strong>.</p>
</dd>
<dt><strong><a name="tls1multi_aad_ossl_cipher_param_tls1_multiblock_aad_octet_string" class="item">&quot;tls1multi_aad&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD</strong>) &lt;octet string&gt;</a></strong></dt>

<dd>
<p>Sets the authenticated additional data used by a TLS1 multiblock cipher operation.
The supplied data consists of 13 bytes of record data containing:
Bytes 0-7: The sequence number of the first record
Byte 8: The record type
Byte 9-10: The protocol version
Byte 11-12: Input length (Always 0)</p>
<p>&quot;tls1multi_interleave&quot; must also be set for this operation.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="controls">CONTROLS</a></h1>
<p>The Mappings from <a href="#evp_cipher_ctx_ctrl"><code>EVP_CIPHER_CTX_ctrl()</code></a> identifiers to PARAMETERS are listed
in the following section. See the <a href="#parameters">PARAMETERS</a> section for more details.</p>
<p><a href="#evp_cipher_ctx_ctrl"><code>EVP_CIPHER_CTX_ctrl()</code></a> can be used to send the following standard controls:</p>
<dl>
<dt><strong><a name="evp_ctrl_aead_set_ivlen_and_evp_ctrl_get_ivlen" class="item">EVP_CTRL_AEAD_SET_IVLEN and EVP_CTRL_GET_IVLEN</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> and
<a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> get called with an <em>OSSL_PARAM(3)</em> item with the
key &quot;ivlen&quot; (<strong>OSSL_CIPHER_PARAM_IVLEN</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_aead_set_iv_fixed" class="item">EVP_CTRL_AEAD_SET_IV_FIXED</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key &quot;tlsivfixed&quot;
(<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_IV_FIXED</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_aead_set_mac_key" class="item">EVP_CTRL_AEAD_SET_MAC_KEY</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key &quot;mackey&quot;
(<strong>OSSL_CIPHER_PARAM_AEAD_MAC_KEY</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_aead_set_tag_and_evp_ctrl_aead_get_tag" class="item">EVP_CTRL_AEAD_SET_TAG and EVP_CTRL_AEAD_GET_TAG</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> and
<a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> get called with an <em>OSSL_PARAM(3)</em> item with the
key &quot;tag&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TAG</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_ccm_set_l" class="item">EVP_CTRL_CCM_SET_L</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key &quot;ivlen&quot; (<strong>OSSL_CIPHER_PARAM_IVLEN</strong>)
with a value of (15 - L)</p>
</dd>
<dt><strong><a name="evp_ctrl_copy" class="item">EVP_CTRL_COPY</a></strong></dt>

<dd>
<p>There is no OSSL_PARAM mapping for this. Use <code>EVP_CIPHER_CTX_copy()</code> instead.</p>
</dd>
<dt><strong><a name="evp_ctrl_gcm_set_iv_inv" class="item">EVP_CTRL_GCM_SET_IV_INV</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key &quot;tlsivinv&quot;
(<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_SET_IV_INV</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_rand_key" class="item">EVP_CTRL_RAND_KEY</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key &quot;randkey&quot;
(<strong>OSSL_CIPHER_PARAM_RANDOM_KEY</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_set_key_length" class="item">EVP_CTRL_SET_KEY_LENGTH</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key &quot;keylen&quot; (<strong>OSSL_CIPHER_PARAM_KEYLEN</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_set_rc2_key_bits_and_evp_ctrl_get_rc2_key_bits" class="item">EVP_CTRL_SET_RC2_KEY_BITS and EVP_CTRL_GET_RC2_KEY_BITS</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> and
<a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> get called with an <em>OSSL_PARAM(3)</em> item with the
key &quot;keybits&quot; (<strong>OSSL_CIPHER_PARAM_RC2_KEYBITS</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_set_rc5_rounds_and_evp_ctrl_get_rc5_rounds" class="item">EVP_CTRL_SET_RC5_ROUNDS and EVP_CTRL_GET_RC5_ROUNDS</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> and
<a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> get called with an <em>OSSL_PARAM(3)</em> item with the
key &quot;rounds&quot; (<strong>OSSL_CIPHER_PARAM_ROUNDS</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_set_speed" class="item">EVP_CTRL_SET_SPEED</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key &quot;speed&quot; (<strong>OSSL_CIPHER_PARAM_SPEED</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_gcm_iv_gen" class="item">EVP_CTRL_GCM_IV_GEN</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> gets called
with an <em>OSSL_PARAM(3)</em> item with the key
&quot;tlsivgen&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_GET_IV_GEN</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_aead_tls1_aad" class="item">EVP_CTRL_AEAD_TLS1_AAD</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> get called
with an <em>OSSL_PARAM(3)</em> item with the key
&quot;tlsaad&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD</strong>)
followed by <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> with a key of
&quot;tlsaadpad&quot; (<strong>OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_tls1_1_multiblock_max_bufsize" class="item">EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>,
<a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called with an <em>OSSL_PARAM(3)</em> item with the
key OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT
followed by <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> with a key of
&quot;tls1multi_maxbufsz&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_tls1_1_multiblock_aad" class="item">EVP_CTRL_TLS1_1_MULTIBLOCK_AAD</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with <em>OSSL_PARAM(3)</em> items with the keys
&quot;tls1multi_aad&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD</strong>) and
&quot;tls1multi_interleave&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</strong>)
followed by <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> with keys of
&quot;tls1multi_aadpacklen&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN</strong>) and
&quot;tls1multi_interleave&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</strong>).</p>
</dd>
<dt><strong><a name="evp_ctrl_tls1_1_multiblock_encrypt" class="item">EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT</a></strong></dt>

<dd>
<p>When used with a fetched <strong>EVP_CIPHER</strong>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a> gets called
with <em>OSSL_PARAM(3)</em> items with the keys
&quot;tls1multi_enc&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC</strong>),
&quot;tls1multi_encin&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN</strong>) and
&quot;tls1multi_interleave&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE</strong>),
followed by <a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a> with a key of
&quot;tls1multi_enclen&quot; (<strong>OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN</strong>).</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="flags">FLAGS</a></h1>
<p><a href="#evp_cipher_ctx_set_flags"><code>EVP_CIPHER_CTX_set_flags()</code></a>, <code>EVP_CIPHER_CTX_clear_flags()</code> and <code>EVP_CIPHER_CTX_test_flags()</code>.
can be used to manipulate and test these <strong>EVP_CIPHER_CTX</strong> flags:</p>
<dl>
<dt><strong><a name="evp_ciph_no_padding" class="item">EVP_CIPH_NO_PADDING</a></strong></dt>

<dd>
<p>Used by <a href="#evp_cipher_ctx_set_padding"><code>EVP_CIPHER_CTX_set_padding()</code></a>.</p>
<p>See also <a href="#gettable_and_settable_evp_cipher_ctx_parameters">Gettable and Settable EVP_CIPHER_CTX parameters</a> &quot;padding&quot;</p>
</dd>
<dt><strong><a name="evp_ciph_flag_length_bits" class="item">EVP_CIPH_FLAG_LENGTH_BITS</a></strong></dt>

<dd>
<p>See <a href="#settable_evp_cipher_ctx_parameters">Settable EVP_CIPHER_CTX parameters</a> &quot;use-bits&quot;.</p>
</dd>
<dt><strong><a name="evp_cipher_ctx_flag_wrap_allow" class="item">EVP_CIPHER_CTX_FLAG_WRAP_ALLOW</a></strong></dt>

<dd>
<p>Used for Legacy purposes only. This flag needed to be set to indicate the
cipher handled wrapping.</p>
</dd>
</dl>
<p><code>EVP_CIPHER_flags()</code> uses the following flags that
have mappings to <a href="#gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a>:</p>
<dl>
<dt><strong><a name="evp_ciph_flag_aead_cipher" class="item">EVP_CIPH_FLAG_AEAD_CIPHER</a></strong></dt>

<dd>
<p>See <a href="#gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a> &quot;aead&quot;.</p>
</dd>
<dt><strong><a name="evp_ciph_custom_iv" class="item">EVP_CIPH_CUSTOM_IV</a></strong></dt>

<dd>
<p>See <a href="#gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a> &quot;custom-iv&quot;.</p>
</dd>
<dt><strong><a name="evp_ciph_flag_cts" class="item">EVP_CIPH_FLAG_CTS</a></strong></dt>

<dd>
<p>See <a href="#gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a> &quot;cts&quot;.</p>
</dd>
<dt><strong><a name="evp_ciph_flag_tls1_1_multiblock" class="item">EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK;</a></strong></dt>

<dd>
<p>See <a href="#gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a> &quot;tls-multi&quot;.</p>
</dd>
<dt><strong><a name="evp_ciph_rand_key" class="item">EVP_CIPH_RAND_KEY</a></strong></dt>

<dd>
<p>See <a href="#gettable_evp_cipher_parameters">Gettable EVP_CIPHER parameters</a> &quot;has-randkey&quot;.</p>
</dd>
</dl>
<p><code>EVP_CIPHER_flags()</code> uses the following flags for legacy purposes only:</p>
<dl>
<dt><strong><a name="evp_ciph_variable_length" class="item">EVP_CIPH_VARIABLE_LENGTH</a></strong></dt>

<dt><strong><a name="evp_ciph_flag_custom_cipher" class="item">EVP_CIPH_FLAG_CUSTOM_CIPHER</a></strong></dt>

<dt><strong><a name="evp_ciph_always_call_init" class="item">EVP_CIPH_ALWAYS_CALL_INIT</a></strong></dt>

<dt><strong><a name="evp_ciph_ctrl_init" class="item">EVP_CIPH_CTRL_INIT</a></strong></dt>

<dt><strong><a name="evp_ciph_custom_key_length" class="item">EVP_CIPH_CUSTOM_KEY_LENGTH</a></strong></dt>

<dt><strong><a name="evp_ciph_custom_copy" class="item">EVP_CIPH_CUSTOM_COPY</a></strong></dt>

<dt><strong><a name="evp_ciph_flag_default_asn1" class="item">EVP_CIPH_FLAG_DEFAULT_ASN1</a></strong></dt>

<dd>
<p>See <em>EVP_CIPHER_meth_set_flags(3)</em> for further information related to the above
flags.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="return_values">RETURN VALUES</a></h1>
<p><a href="#evp_cipher_fetch"><code>EVP_CIPHER_fetch()</code></a> returns a pointer to a <strong>EVP_CIPHER</strong> for success
and <strong>NULL</strong> for failure.</p>
<p><a href="#evp_cipher_up_ref"><code>EVP_CIPHER_up_ref()</code></a> returns 1 for success or 0 otherwise.</p>
<p><a href="#evp_cipher_ctx_new"><code>EVP_CIPHER_CTX_new()</code></a> returns a pointer to a newly created
<strong>EVP_CIPHER_CTX</strong> for success and <strong>NULL</strong> for failure.</p>
<p>EVP_EncryptInit_ex2(), <a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a> and <code>EVP_EncryptFinal_ex()</code>
return 1 for success and 0 for failure.</p>
<p>EVP_DecryptInit_ex2() and <code>EVP_DecryptUpdate()</code> return 1 for success and 0 for failure.
<code>EVP_DecryptFinal_ex()</code> returns 0 if the decrypt failed or 1 for success.</p>
<p>EVP_CipherInit_ex2() and <code>EVP_CipherUpdate()</code> return 1 for success and 0 for failure.
<code>EVP_CipherFinal_ex()</code> returns 0 for a decryption failure or 1 for success.</p>
<p><a href="#evp_cipher"><code>EVP_Cipher()</code></a> returns 1 on success or 0 on failure, if the flag
<strong>EVP_CIPH_FLAG_CUSTOM_CIPHER</strong> is not set for the cipher.
<a href="#evp_cipher"><code>EVP_Cipher()</code></a> returns the number of bytes written to <em>out</em> for encryption / decryption, or
the number of bytes authenticated in a call specifying AAD for an AEAD cipher, if the flag
<strong>EVP_CIPH_FLAG_CUSTOM_CIPHER</strong> is set for the cipher.</p>
<p><a href="#evp_cipher_ctx_reset"><code>EVP_CIPHER_CTX_reset()</code></a> returns 1 for success and 0 for failure.</p>
<p><a href="#evp_get_cipherbyname"><code>EVP_get_cipherbyname()</code></a>, <code>EVP_get_cipherbynid()</code> and <code>EVP_get_cipherbyobj()</code>
return an <strong>EVP_CIPHER</strong> structure or NULL on error.</p>
<p><a href="#evp_cipher_get_nid"><code>EVP_CIPHER_get_nid()</code></a> and <code>EVP_CIPHER_CTX_get_nid()</code> return a NID.</p>
<p><a href="#evp_cipher_get_block_size"><code>EVP_CIPHER_get_block_size()</code></a> and <code>EVP_CIPHER_CTX_get_block_size()</code> return the
block size.</p>
<p><a href="#evp_cipher_get_key_length"><code>EVP_CIPHER_get_key_length()</code></a> and <code>EVP_CIPHER_CTX_get_key_length()</code> return the key
length.</p>
<p><a href="#evp_cipher_ctx_set_padding"><code>EVP_CIPHER_CTX_set_padding()</code></a> always returns 1.</p>
<p><a href="#evp_cipher_get_iv_length"><code>EVP_CIPHER_get_iv_length()</code></a> and <code>EVP_CIPHER_CTX_get_iv_length()</code> return the IV
length or zero if the cipher does not use an IV.</p>
<p><a href="#evp_cipher_ctx_get_tag_length"><code>EVP_CIPHER_CTX_get_tag_length()</code></a> return the tag length or zero if the cipher
does not use a tag.</p>
<p><a href="#evp_cipher_get_type"><code>EVP_CIPHER_get_type()</code></a> and <code>EVP_CIPHER_CTX_get_type()</code> return the NID of the
cipher's OBJECT IDENTIFIER or NID_undef if it has no defined
OBJECT IDENTIFIER.</p>
<p><code>EVP_CIPHER_CTX_cipher()</code> returns an <strong>EVP_CIPHER</strong> structure.</p>
<p><a href="#evp_cipher_ctx_get_num"><code>EVP_CIPHER_CTX_get_num()</code></a> returns a nonnegative num value or
<strong>EVP_CTRL_RET_UNSUPPORTED</strong> if the implementation does not support the call
or on any other error.</p>
<p><code>EVP_CIPHER_CTX_set_num()</code> returns 1 on success and 0 if the implementation
does not support the call or on any other error.</p>
<p><a href="#evp_cipher_ctx_is_encrypting"><code>EVP_CIPHER_CTX_is_encrypting()</code></a> returns 1 if the <em>ctx</em> is set up for encryption
0 otherwise.</p>
<p>EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return greater
than zero for success and zero or a negative number on failure.</p>
<p><a href="#evp_cipher_ctx_rand_key"><code>EVP_CIPHER_CTX_rand_key()</code></a> returns 1 for success and zero or a negative number
for failure.</p>
<p><a href="#evp_cipher_names_do_all"><code>EVP_CIPHER_names_do_all()</code></a> returns 1 if the callback was called for all names.
A return value of 0 means that the callback was not called for any names.</p>
<p>
</p>
<hr />
<h1><a name="cipher_listing">CIPHER LISTING</a></h1>
<p>All algorithms have a fixed key length unless otherwise stated.</p>
<p>Refer to <a href="#see_also">SEE ALSO</a> for the full list of ciphers available through the EVP
interface.</p>
<dl>
<dt><strong><a name="evp_enc_null" class="item"><code>EVP_enc_null()</code></a></strong></dt>

<dd>
<p>Null cipher: does nothing.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="aead_interface">AEAD INTERFACE</a></h1>
<p>The EVP interface for Authenticated Encryption with Associated Data (AEAD)
modes are subtly altered and several additional <em>ctrl</em> operations are supported
depending on the mode specified.</p>
<p>To specify additional authenticated data (AAD), a call to <code>EVP_CipherUpdate()</code>,
<a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a> or <code>EVP_DecryptUpdate()</code> should be made with the output
parameter <em>out</em> set to <strong>NULL</strong>. In this case, on success, the parameter
<em>outl</em> is set to the number of bytes authenticated.</p>
<p>When decrypting, the return value of <code>EVP_DecryptFinal()</code> or <code>EVP_CipherFinal()</code>
indicates whether the operation was successful. If it does not indicate success,
the authentication operation has failed and any output data <strong>MUST NOT</strong> be used
as it is corrupted.</p>
<p>
</p>
<h2><a name="gcm_and_ocb_modes">GCM and OCB Modes</a></h2>
<p>The following <em>ctrl</em>s are supported in GCM and OCB modes.</p>
<dl>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)</strong></dt>

<dd>
<p>Sets the IV length. This call can only be made before specifying an IV. If
not called a default IV length is used.</p>
<p>For GCM AES and OCB AES the default is 12 (i.e. 96 bits). For OCB mode the
maximum is 15.</p>
</dd>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag)</strong></dt>

<dd>
<p>Writes <code>taglen</code> bytes of the tag value to the buffer indicated by <code>tag</code>.
This call can only be made when encrypting data and <strong>after</strong> all data has been
processed (e.g. after an <a href="#evp_encryptfinal"><code>EVP_EncryptFinal()</code></a> call).</p>
<p>For OCB, <code>taglen</code> must either be 16 or the value previously set via
<strong>EVP_CTRL_AEAD_SET_TAG</strong>.</p>
</dd>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)</strong></dt>

<dd>
<p>When decrypting, this call sets the expected tag to <code>taglen</code> bytes from <code>tag</code>.
<code>taglen</code> must be between 1 and 16 inclusive.
The tag must be set prior to any call to <code>EVP_DecryptFinal()</code> or
<code>EVP_DecryptFinal_ex()</code>.</p>
<p>For GCM, this call is only valid when decrypting data.</p>
<p>For OCB, this call is valid when decrypting data to set the expected tag,
and when encrypting to set the desired tag length.</p>
<p>In OCB mode, calling this when encrypting with <code>tag</code> set to <code>NULL</code> sets the
tag length. The tag length can only be set before specifying an IV. If this is
not called prior to setting the IV during encryption, then a default tag length
is used.</p>
<p>For OCB AES, the default tag length is 16 (i.e. 128 bits).  It is also the
maximum tag length for OCB.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="ccm_mode">CCM Mode</a></h2>
<p>The EVP interface for CCM mode is similar to that of the GCM mode but with a
few additional requirements and different <em>ctrl</em> values.</p>
<p>For CCM mode, the total plaintext or ciphertext length <strong>MUST</strong> be passed to
<code>EVP_CipherUpdate()</code>, <a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a> or <code>EVP_DecryptUpdate()</code> with the output
and input parameters (<em>in</em> and <em>out</em>) set to <strong>NULL</strong> and the length passed in
the <em>inl</em> parameter.</p>
<p>The following <em>ctrl</em>s are supported in CCM mode.</p>
<dl>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)</strong></dt>

<dd>
<p>This call is made to set the expected <strong>CCM</strong> tag value when decrypting or
the length of the tag (with the <code>tag</code> parameter set to NULL) when encrypting.
The tag length is often referred to as <strong>M</strong>. If not set a default value is
used (12 for AES). When decrypting, the tag needs to be set before passing
in data to be decrypted, but as in GCM and OCB mode, it can be set after
passing additional authenticated data (see <a href="#aead_interface">AEAD INTERFACE</a>).</p>
</dd>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_L, ivlen, NULL)</strong></dt>

<dd>
<p>Sets the CCM <strong>L</strong> value. If not set a default is used (8 for AES).</p>
</dd>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)</strong></dt>

<dd>
<p>Sets the CCM nonce (IV) length. This call can only be made before specifying a
nonce value. The nonce length is given by <strong>15 - L</strong> so it is 7 by default for
AES.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="siv_mode">SIV Mode</a></h2>
<p>For SIV mode ciphers the behaviour of the EVP interface is subtly
altered and several additional ctrl operations are supported.</p>
<p>To specify any additional authenticated data (AAD) and/or a Nonce, a call to
<code>EVP_CipherUpdate()</code>, <a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a> or <code>EVP_DecryptUpdate()</code> should be made
with the output parameter <em>out</em> set to <strong>NULL</strong>.</p>
<p>RFC5297 states that the Nonce is the last piece of AAD before the actual
encrypt/decrypt takes place. The API does not differentiate the Nonce from
other AAD.</p>
<p>When decrypting the return value of <code>EVP_DecryptFinal()</code> or <code>EVP_CipherFinal()</code>
indicates if the operation was successful. If it does not indicate success
the authentication operation has failed and any output data <strong>MUST NOT</strong>
be used as it is corrupted.</p>
<p>The API does not store the the SIV (Synthetic Initialization Vector) in
the cipher text. Instead, it is stored as the tag within the EVP_CIPHER_CTX.
The SIV must be retrieved from the context after encryption, and set into
the context before decryption.</p>
<p>This differs from <a href="http://www.ietf.org/rfc/rfc5297.txt" class="rfc">RFC5297</a> in that the cipher output from encryption, and
the cipher input to decryption, does not contain the SIV. This also means
that the plain text and cipher text lengths are identical.</p>
<p>The following ctrls are supported in SIV mode, and are used to get and set
the Synthetic Initialization Vector:</p>
<dl>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag);</strong></dt>

<dd>
<p>Writes <em>taglen</em> bytes of the tag value (the Synthetic Initialization Vector)
to the buffer indicated by <em>tag</em>. This call can only be made when encrypting
data and <strong>after</strong> all data has been processed (e.g. after an <a href="#evp_encryptfinal"><code>EVP_EncryptFinal()</code></a>
call). For SIV mode the taglen must be 16.</p>
</dd>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag);</strong></dt>

<dd>
<p>Sets the expected tag (the Synthetic Initialization Vector) to <em>taglen</em>
bytes from <em>tag</em>. This call is only legal when decrypting data and must be
made <strong>before</strong> any data is processed (e.g. before any <code>EVP_DecryptUpdate()</code>
calls). For SIV mode the taglen must be 16.</p>
</dd>
</dl>
<p>SIV mode makes two passes over the input data, thus, only one call to
<code>EVP_CipherUpdate()</code>, <a href="#evp_encryptupdate"><code>EVP_EncryptUpdate()</code></a> or <code>EVP_DecryptUpdate()</code> should be made
with <em>out</em> set to a non-<strong>NULL</strong> value. A call to <code>EVP_DecryptFinal()</code> or
<code>EVP_CipherFinal()</code> is not required, but will indicate if the update
operation succeeded.</p>
<p>
</p>
<h2><a name="chacha20_poly1305">ChaCha20-Poly1305</a></h2>
<p>The following <em>ctrl</em>s are supported for the ChaCha20-Poly1305 AEAD algorithm.</p>
<dl>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)</strong></dt>

<dd>
<p>Sets the nonce length. This call is now redundant since the only valid value
is the default length of 12 (i.e. 96 bits).
Prior to OpenSSL 3.0 a nonce of less than 12 bytes could be used to automatically
pad the iv with leading 0 bytes to make it 12 bytes in length.</p>
</dd>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag)</strong></dt>

<dd>
<p>Writes <code>taglen</code> bytes of the tag value to the buffer indicated by <code>tag</code>.
This call can only be made when encrypting data and <strong>after</strong> all data has been
processed (e.g. after an <a href="#evp_encryptfinal"><code>EVP_EncryptFinal()</code></a> call).</p>
<p><code>taglen</code> specified here must be 16 (<strong>POLY1305_BLOCK_SIZE</strong>, i.e. 128-bits) or
less.</p>
</dd>
<dt><strong>EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, taglen, tag)</strong></dt>

<dd>
<p>Sets the expected tag to <code>taglen</code> bytes from <code>tag</code>.
The tag length can only be set before specifying an IV.
<code>taglen</code> must be between 1 and 16 (<strong>POLY1305_BLOCK_SIZE</strong>) inclusive.
This call is only valid when decrypting data.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="notes">NOTES</a></h1>
<p>Where possible the <strong>EVP</strong> interface to symmetric ciphers should be used in
preference to the low-level interfaces. This is because the code then becomes
transparent to the cipher used and much more flexible. Additionally, the
<strong>EVP</strong> interface will ensure the use of platform specific cryptographic
acceleration such as AES-NI (the low-level interfaces do not provide the
guarantee).</p>
<p>PKCS padding works by adding <strong>n</strong> padding bytes of value <strong>n</strong> to make the total
length of the encrypted data a multiple of the block size. Padding is always
added so if the data is already a multiple of the block size <strong>n</strong> will equal
the block size. For example if the block size is 8 and 11 bytes are to be
encrypted then 5 padding bytes of value 5 will be added.</p>
<p>When decrypting the final block is checked to see if it has the correct form.</p>
<p>Although the decryption operation can produce an error if padding is enabled,
it is not a strong test that the input data or key is correct. A random block
has better than 1 in 256 chance of being of the correct format and problems with
the input data earlier on will not produce a final decrypt error.</p>
<p>If padding is disabled then the decryption operation will always succeed if
the total amount of data decrypted is a multiple of the block size.</p>
<p>The functions <a href="#evp_encryptinit"><code>EVP_EncryptInit()</code></a>, <a href="#evp_encryptinit_ex"><code>EVP_EncryptInit_ex()</code></a>,
<a href="#evp_encryptfinal"><code>EVP_EncryptFinal()</code></a>, <code>EVP_DecryptInit()</code>, <code>EVP_DecryptInit_ex()</code>,
<code>EVP_CipherInit()</code>, <code>EVP_CipherInit_ex()</code> and <code>EVP_CipherFinal()</code> are obsolete
but are retained for compatibility with existing code. New code should
use EVP_EncryptInit_ex2(), <code>EVP_EncryptFinal_ex()</code>, EVP_DecryptInit_ex2(),
<code>EVP_DecryptFinal_ex()</code>, EVP_CipherInit_ex2() and <code>EVP_CipherFinal_ex()</code>
because they can reuse an existing context without allocating and freeing
it up on each call.</p>
<p>There are some differences between functions <code>EVP_CipherInit()</code> and
<code>EVP_CipherInit_ex()</code>, significant in some circumstances. <code>EVP_CipherInit()</code> fills
the passed context object with zeros.  As a consequence, <code>EVP_CipherInit()</code> does
not allow step-by-step initialization of the ctx when the <em>key</em> and <em>iv</em> are
passed in separate calls. It also means that the flags set for the CTX are
removed, and it is especially important for the
<strong>EVP_CIPHER_CTX_FLAG_WRAP_ALLOW</strong> flag treated specially in
<code>EVP_CipherInit_ex()</code>.</p>
<p>Ignoring failure returns of the <strong>EVP_CIPHER_CTX</strong> initialization functions can
lead to subsequent undefined behavior when calling the functions that update or
finalize the context. The only valid calls on the <strong>EVP_CIPHER_CTX</strong> when
initialization fails are calls that attempt another initialization of the
context or release the context.</p>
<p><code>EVP_get_cipherbynid()</code>, and <code>EVP_get_cipherbyobj()</code> are implemented as macros.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p><strong>EVP_MAX_KEY_LENGTH</strong> and <strong>EVP_MAX_IV_LENGTH</strong> only refer to the internal
ciphers with default key lengths. If custom ciphers exceed these values the
results are unpredictable. This is because it has become standard practice to
define a generic key as a fixed unsigned char array containing
<strong>EVP_MAX_KEY_LENGTH</strong> bytes.</p>
<p>The ASN1 code is incomplete (and sometimes inaccurate) it has only been tested
for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode.</p>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>Encrypt a string using IDEA:</p>
<pre>
 <span class="keyword">int</span> <span class="variable">do_crypt</span><span class="operator">(</span><span class="variable">char</span> <span class="variable">*outfile</span><span class="operator">)</span>
 <span class="operator">{</span>
     <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">outbuf</span><span class="operator">[</span><span class="number">1024</span><span class="operator">]</span><span class="operator">;</span>
     <span class="keyword">int</span> <span class="variable">outlen</span><span class="operator">,</span> <span class="variable">tmplen</span><span class="operator">;</span>
     <span class="regex">/*
      * Bogus key and IV: we'd normally set these from
      * another source.
      */</span>
     <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">key</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span><span class="number">0</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">,</span><span class="number">5</span><span class="operator">,</span><span class="number">6</span><span class="operator">,</span><span class="number">7</span><span class="operator">,</span><span class="number">8</span><span class="operator">,</span><span class="number">9</span><span class="operator">,</span><span class="number">10</span><span class="operator">,</span><span class="number">11</span><span class="operator">,</span><span class="number">12</span><span class="operator">,</span><span class="number">13</span><span class="operator">,</span><span class="number">14</span><span class="operator">,</span><span class="number">15</span><span class="operator">}</span><span class="operator">;</span>
     <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">iv</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">,</span><span class="number">5</span><span class="operator">,</span><span class="number">6</span><span class="operator">,</span><span class="number">7</span><span class="operator">,</span><span class="number">8</span><span class="operator">}</span><span class="operator">;</span>
     <span class="variable">char</span> <span class="variable">intext</span><span class="operator">[]</span> <span class="operator">=</span> <span class="string">"Some Crypto Text"</span><span class="operator">;</span>
     <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">;</span>
     <span class="variable">FILE</span> <span class="variable">*out</span><span class="operator">;</span>
</pre>
<pre>
     <span class="variable">ctx</span> <span class="operator">=</span> <span class="variable">EVP_CIPHER_CTX_new</span><span class="operator">();</span>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_EncryptInit_ex2</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">EVP_idea_cbc</span><span class="operator">(),</span> <span class="variable">key</span><span class="operator">,</span> <span class="variable">iv</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">))</span> <span class="operator">{</span>
         <span class="regex">/* Error */</span>
         <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
     <span class="operator">}</span>
</pre>
<pre>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_EncryptUpdate</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">outbuf</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="variable">outlen</span><span class="operator">,</span> <span class="variable">intext</span><span class="operator">,</span> <span class="variable">strlen</span><span class="operator">(</span><span class="variable">intext</span><span class="operator">)))</span> <span class="operator">{</span>
         <span class="regex">/* Error */</span>
         <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
     <span class="operator">}</span>
     <span class="regex">/*
      * Buffer passed to EVP_EncryptFinal() must be after data just
      * encrypted to avoid overwriting it.
      */</span>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_EncryptFinal_ex</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">outbuf</span> <span class="operator">+</span> <span class="variable">outlen</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="variable">tmplen</span><span class="operator">))</span> <span class="operator">{</span>
         <span class="regex">/* Error */</span>
         <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
     <span class="operator">}</span>
     <span class="variable">outlen</span> <span class="operator">+=</span> <span class="variable">tmplen</span><span class="operator">;</span>
     <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
     <span class="regex">/*
      * Need binary mode for fopen because encrypted data is
      * binary data. Also cannot use strlen() on it because
      * it won't be NUL terminated and may contain embedded
      * NULs.
      */</span>
     <span class="variable">out</span> <span class="operator">=</span> <span class="variable">fopen</span><span class="operator">(</span><span class="variable">outfile</span><span class="operator">,</span> <span class="string">"wb"</span><span class="operator">);</span>
     <span class="keyword">if</span> <span class="operator">(</span><span class="variable">out</span> <span class="operator">==</span> <span class="variable">NULL</span><span class="operator">)</span> <span class="operator">{</span>
         <span class="regex">/* Error */</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
     <span class="operator">}</span>
     <span class="variable">fwrite</span><span class="operator">(</span><span class="variable">outbuf</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">outlen</span><span class="operator">,</span> <span class="variable">out</span><span class="operator">);</span>
     <span class="variable">fclose</span><span class="operator">(</span><span class="variable">out</span><span class="operator">);</span>
     <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
      <span class="operator">}</span>
</pre>
<p>The ciphertext from the above example can be decrypted using the <strong>openssl</strong>
utility with the command line (shown on two lines for clarity):</p>
<pre>
 openssl idea -d \
     -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 &lt;filename</pre>
<p>General encryption and decryption function example using FILE I/O and AES128
with a 128-bit key:</p>
<pre>
 <span class="keyword">int</span> <span class="variable">do_crypt</span><span class="operator">(</span><span class="variable">FILE</span> <span class="variable">*in</span><span class="operator">,</span> <span class="variable">FILE</span> <span class="variable">*out</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">do_encrypt</span><span class="operator">)</span>
 <span class="operator">{</span>
     <span class="regex">/* Allow enough space in output buffer for additional block */</span>
     <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">inbuf</span><span class="operator">[</span><span class="number">1024</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">outbuf</span><span class="operator">[</span><span class="number">1024</span> <span class="operator">+</span> <span class="variable">EVP_MAX_BLOCK_LENGTH</span><span class="operator">]</span><span class="operator">;</span>
     <span class="keyword">int</span> <span class="variable">inlen</span><span class="operator">,</span> <span class="variable">outlen</span><span class="operator">;</span>
     <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span><span class="operator">;</span>
     <span class="regex">/*
      * Bogus key and IV: we'd normally set these from
      * another source.
      */</span>
     <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">key</span><span class="operator">[]</span> <span class="operator">=</span> <span class="string">"0123456789abcdeF"</span><span class="operator">;</span>
     <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">iv</span><span class="operator">[]</span> <span class="operator">=</span> <span class="string">"1234567887654321"</span><span class="operator">;</span>
</pre>
<pre>
     <span class="regex">/* Don't set key or IV right away; we want to check lengths */</span>
     <span class="variable">ctx</span> <span class="operator">=</span> <span class="variable">EVP_CIPHER_CTX_new</span><span class="operator">();</span>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_CipherInit_ex2</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">EVP_aes_128_cbc</span><span class="operator">(),</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span>
                             <span class="variable">do_encrypt</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">))</span> <span class="operator">{</span>
         <span class="regex">/* Error */</span>
         <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
     <span class="operator">}</span>
     <span class="variable">OPENSSL_assert</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX_get_key_length</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">)</span> <span class="operator">==</span> <span class="number">16</span><span class="operator">);</span>
     <span class="variable">OPENSSL_assert</span><span class="operator">(</span><span class="variable">EVP_CIPHER_CTX_get_iv_length</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">)</span> <span class="operator">==</span> <span class="number">16</span><span class="operator">);</span>
</pre>
<pre>
     <span class="regex">/* Now we can set key and IV */</span>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_CipherInit_ex2</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="variable">key</span><span class="operator">,</span> <span class="variable">iv</span><span class="operator">,</span> <span class="variable">do_encrypt</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">))</span> <span class="operator">{</span>
         <span class="regex">/* Error */</span>
         <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
     <span class="operator">}</span>
</pre>
<pre>
     <span class="keyword">for</span> <span class="operator">(;;)</span> <span class="operator">{</span>
         <span class="variable">inlen</span> <span class="operator">=</span> <span class="variable">fread</span><span class="operator">(</span><span class="variable">inbuf</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">1024</span><span class="operator">,</span> <span class="variable">in</span><span class="operator">);</span>
         <span class="keyword">if</span> <span class="operator">(</span><span class="variable">inlen</span> <span class="operator">&lt;=</span> <span class="number">0</span><span class="operator">)</span>
             <span class="keyword">break</span><span class="operator">;</span>
         <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_CipherUpdate</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">outbuf</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="variable">outlen</span><span class="operator">,</span> <span class="variable">inbuf</span><span class="operator">,</span> <span class="variable">inlen</span><span class="operator">))</span> <span class="operator">{</span>
             <span class="regex">/* Error */</span>
             <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
             <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
         <span class="operator">}</span>
         <span class="variable">fwrite</span><span class="operator">(</span><span class="variable">outbuf</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">outlen</span><span class="operator">,</span> <span class="variable">out</span><span class="operator">);</span>
     <span class="operator">}</span>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_CipherFinal_ex</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">outbuf</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="variable">outlen</span><span class="operator">))</span> <span class="operator">{</span>
         <span class="regex">/* Error */</span>
         <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
     <span class="operator">}</span>
     <span class="variable">fwrite</span><span class="operator">(</span><span class="variable">outbuf</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">outlen</span><span class="operator">,</span> <span class="variable">out</span><span class="operator">);</span>
</pre>
<pre>
     <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
     <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
      <span class="operator">}</span>
</pre>
<p>Encryption using AES-CBC with a 256-bit key with &quot;CS1&quot; ciphertext stealing.</p>
<pre>
 <span class="keyword">int</span> <span class="variable">encrypt</span><span class="operator">(</span><span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*key</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*iv</span><span class="operator">,</span>
             <span class="variable">const</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*msg</span><span class="operator">,</span> <span class="variable">size_t</span> <span class="variable">msg_len</span><span class="operator">,</span> <span class="variable">unsigned</span> <span class="variable">char</span> <span class="variable">*out</span><span class="operator">)</span>
 <span class="operator">{</span>
    <span class="regex">/*
     * This assumes that key size is 32 bytes and the iv is 16 bytes.
     * For ciphertext stealing mode the length of the ciphertext "out" will be
     * the same size as the plaintext size "msg_len".
     * The "msg_len" can be any size &gt;= 16.
     */</span>
     <span class="keyword">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> <span class="variable">encrypt</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">outlen</span><span class="operator">,</span> <span class="variable">len</span><span class="operator">;</span>
     <span class="variable">EVP_CIPHER_CTX</span> <span class="variable">*ctx</span> <span class="operator">=</span> <span class="variable">NULL</span><span class="operator">;</span>
     <span class="variable">EVP_CIPHER</span> <span class="variable">*cipher</span> <span class="operator">=</span> <span class="variable">NULL</span><span class="operator">;</span>
     <span class="variable">OSSL_PARAM</span> <span class="variable">params</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">;</span>
</pre>
<pre>
     <span class="variable">ctx</span> <span class="operator">=</span> <span class="variable">EVP_CIPHER_CTX_new</span><span class="operator">();</span>
     <span class="variable">cipher</span> <span class="operator">=</span> <span class="variable">EVP_CIPHER_fetch</span><span class="operator">(</span><span class="variable">NULL</span><span class="operator">,</span> <span class="string">"AES-256-CBC-CTS"</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">);</span>
     <span class="keyword">if</span> <span class="operator">(</span><span class="variable">ctx</span> <span class="operator">==</span> <span class="variable">NULL</span> <span class="operator">||</span> <span class="variable">cipher</span> <span class="operator">==</span> <span class="variable">NULL</span><span class="operator">)</span>
         <span class="keyword">goto</span> <span class="variable">err</span><span class="operator">;</span>
</pre>
<pre>
     <span class="regex">/*
      * The default is "CS1" so this is not really needed,
      * but would be needed to set either "CS2" or "CS3".
      */</span>
     <span class="variable">params</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="variable">OSSL_PARAM_construct_utf8_string</span><span class="operator">(</span><span class="variable">OSSL_CIPHER_PARAM_CTS_MODE</span><span class="operator">,</span>
                                                  <span class="string">"CS1"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
     <span class="variable">params</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="variable">OSSL_PARAM_construct_end</span><span class="operator">();</span>
</pre>
<pre>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_CipherInit_ex2</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">cipher</span><span class="operator">,</span> <span class="variable">key</span><span class="operator">,</span> <span class="variable">iv</span><span class="operator">,</span> <span class="variable">encrypt</span><span class="operator">,</span> <span class="variable">params</span><span class="operator">))</span>
         <span class="keyword">goto</span> <span class="variable">err</span><span class="operator">;</span>
</pre>
<pre>
     <span class="regex">/* NOTE: CTS mode does not support multiple calls to EVP_CipherUpdate() */</span>
     <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_CipherUpdate</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">out</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="variable">outlen</span><span class="operator">,</span> <span class="variable">msg</span><span class="operator">,</span> <span class="variable">msg_len</span><span class="operator">))</span>
         <span class="keyword">goto</span> <span class="variable">err</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">EVP_CipherFinal_ex</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">,</span> <span class="variable">out</span> <span class="operator">+</span> <span class="variable">outlen</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="variable">len</span><span class="operator">))</span>
         <span class="keyword">goto</span> <span class="variable">err</span><span class="operator">;</span>
     <span class="variable">ret</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
      <span class="variable">err</span><span class="operator">:</span>
     <span class="variable">EVP_CIPHER_free</span><span class="operator">(</span><span class="variable">cipher</span><span class="operator">);</span>
     <span class="variable">EVP_CIPHER_CTX_free</span><span class="operator">(</span><span class="variable">ctx</span><span class="operator">);</span>
     <span class="keyword">return</span> <span class="variable">ret</span><span class="operator">;</span>
      <span class="operator">}</span>
</pre>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><em>evp(7)</em>,
<em>property(7)</em>,
<em>crypto(7)/ALGORITHM FETCHING</em>,
<em>provider-cipher(7)</em>,
<em>life_cycle-cipher(7)</em></p>
<p>Supported ciphers are listed in:</p>
<p><em>EVP_aes_128_gcm(3)</em>,
<em>EVP_aria_128_gcm(3)</em>,
<em>EVP_bf_cbc(3)</em>,
<em>EVP_camellia_128_ecb(3)</em>,
<em>EVP_cast5_cbc(3)</em>,
<em>EVP_chacha20(3)</em>,
<em>EVP_des_cbc(3)</em>,
<em>EVP_desx_cbc(3)</em>,
<em>EVP_idea_cbc(3)</em>,
<em>EVP_rc2_cbc(3)</em>,
<em>EVP_rc4(3)</em>,
<em>EVP_rc5_32_12_16_cbc(3)</em>,
<em>EVP_seed_cbc(3)</em>,
<em>EVP_sm4_cbc(3)</em>,</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p>Support for OCB mode was added in OpenSSL 1.1.0.</p>
<p><strong>EVP_CIPHER_CTX</strong> was made opaque in OpenSSL 1.1.0.  As a result,
<a href="#evp_cipher_ctx_reset"><code>EVP_CIPHER_CTX_reset()</code></a> appeared and <code>EVP_CIPHER_CTX_cleanup()</code>
disappeared.  <code>EVP_CIPHER_CTX_init()</code> remains as an alias for
<a href="#evp_cipher_ctx_reset"><code>EVP_CIPHER_CTX_reset()</code></a>.</p>
<p>The <code>EVP_CIPHER_CTX_cipher()</code> function was deprecated in OpenSSL 3.0; use
EVP_CIPHER_CTX_get0_cipher() instead.</p>
<p>The EVP_EncryptInit_ex2(), EVP_DecryptInit_ex2(), EVP_CipherInit_ex2(),
<a href="#evp_cipher_fetch"><code>EVP_CIPHER_fetch()</code></a>, <a href="#evp_cipher_free"><code>EVP_CIPHER_free()</code></a>, <a href="#evp_cipher_up_ref"><code>EVP_CIPHER_up_ref()</code></a>,
EVP_CIPHER_CTX_get0_cipher(), EVP_CIPHER_CTX_get1_cipher(),
<a href="#evp_cipher_get_params"><code>EVP_CIPHER_get_params()</code></a>, <a href="#evp_cipher_ctx_set_params"><code>EVP_CIPHER_CTX_set_params()</code></a>,
<a href="#evp_cipher_ctx_get_params"><code>EVP_CIPHER_CTX_get_params()</code></a>, <a href="#evp_cipher_gettable_params"><code>EVP_CIPHER_gettable_params()</code></a>,
<a href="#evp_cipher_settable_ctx_params"><code>EVP_CIPHER_settable_ctx_params()</code></a>, <a href="#evp_cipher_gettable_ctx_params"><code>EVP_CIPHER_gettable_ctx_params()</code></a>,
<code>EVP_CIPHER_CTX_settable_params()</code> and <code>EVP_CIPHER_CTX_gettable_params()</code>
functions were added in 3.0.</p>
<p>The <code>EVP_CIPHER_nid()</code>, <code>EVP_CIPHER_name()</code>, <code>EVP_CIPHER_block_size()</code>,
<code>EVP_CIPHER_key_length()</code>, <code>EVP_CIPHER_iv_length()</code>, <code>EVP_CIPHER_flags()</code>,
<code>EVP_CIPHER_mode()</code>, <code>EVP_CIPHER_type()</code>, <code>EVP_CIPHER_CTX_nid()</code>,
<code>EVP_CIPHER_CTX_block_size()</code>, <code>EVP_CIPHER_CTX_key_length()</code>,
<code>EVP_CIPHER_CTX_iv_length()</code>, <code>EVP_CIPHER_CTX_tag_length()</code>,
<code>EVP_CIPHER_CTX_num()</code>, <code>EVP_CIPHER_CTX_type()</code>, and <code>EVP_CIPHER_CTX_mode()</code>
functions were renamed to include <code>get</code> or <code>get0</code> in their names in
OpenSSL 3.0, respectively. The old names are kept as non-deprecated
alias macros.</p>
<p>The <code>EVP_CIPHER_CTX_encrypting()</code> function was renamed to
<a href="#evp_cipher_ctx_is_encrypting"><code>EVP_CIPHER_CTX_is_encrypting()</code></a> in OpenSSL 3.0. The old name is kept as
non-deprecated alias macro.</p>
<p>The <a href="#evp_cipher_ctx_flags"><code>EVP_CIPHER_CTX_flags()</code></a> macro was deprecated in OpenSSL 1.1.0.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright 2000-2023 The OpenSSL Project Authors. All Rights Reserved.</p>
<p>Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
<a href="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</a>.</p>

</body>

</html>
